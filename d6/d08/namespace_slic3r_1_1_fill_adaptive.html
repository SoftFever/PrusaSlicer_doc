<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Prusa Slicer: Slic3r::FillAdaptive Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../PrusaSlicer_32px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Prusa Slicer<span id="projectnumber">&#160;2.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d6/d08/namespace_slic3r_1_1_fill_adaptive.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Slic3r::FillAdaptive Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">CubeProperties</a></td></tr>
<tr class="separator:da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html">FillContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d87/class_slic3r_1_1_fill_adaptive_1_1_filler.html">Filler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Octree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dc6/struct_slic3r_1_1_fill_adaptive_1_1_octree_deleter.html">OctreeDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4bea6f8de479db81e6d18ec53d5f73b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a> = bgm::point&lt; float, 2, boost::geometry::cs::cartesian &gt;</td></tr>
<tr class="separator:a4bea6f8de479db81e6d18ec53d5f73b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6a11139ccb39e953a4f28a21ea0961"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a> = bgm::segment&lt; <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a> &gt;</td></tr>
<tr class="separator:a7c6a11139ccb39e953a4f28a21ea0961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef2163df60632bf830aa7ee39d43b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">rtree_t</a> = bgi::rtree&lt; std::pair&lt; <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a>, size_t &gt;, bgi::rstar&lt; 16, 4 &gt; &gt;</td></tr>
<tr class="separator:ad5ef2163df60632bf830aa7ee39d43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cd64cc9ecd14940e8bd93de0b57326"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">OctreePtr</a> = std::unique_ptr&lt; <a class="el" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Octree</a>, <a class="el" href="../../df/dc6/struct_slic3r_1_1_fill_adaptive_1_1_octree_deleter.html">OctreeDeleter</a> &gt;</td></tr>
<tr class="separator:a26cd64cc9ecd14940e8bd93de0b57326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adc8b636ad8932e70ba36382ebb886607"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &gt; </td></tr>
<tr class="memitem:adc8b636ad8932e70ba36382ebb886607"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#adc8b636ad8932e70ba36382ebb886607">triangle_AABB_intersects</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;a, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;b, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;c, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html">BoundingBoxBase</a>&lt; <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &gt; &amp;aabb)</td></tr>
<tr class="separator:adc8b636ad8932e70ba36382ebb886607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a5a8767b9bbd4ad7389906cccac872"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a79a5a8767b9bbd4ad7389906cccac872">adaptive_fill_line_spacing</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/d87/class_slic3r_1_1_print_object.html">PrintObject</a> &amp;print_object)</td></tr>
<tr class="separator:a79a5a8767b9bbd4ad7389906cccac872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3852c9049cfd6489d75430d404c3decd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d00/group___geometry___module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3852c9049cfd6489d75430d404c3decd">transform_to_world</a> ()</td></tr>
<tr class="separator:a3852c9049cfd6489d75430d404c3decd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbdd2308edf307ac8e47f65d3ae1740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d00/group___geometry___module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a6bbdd2308edf307ac8e47f65d3ae1740">transform_to_octree</a> ()</td></tr>
<tr class="separator:a6bbdd2308edf307ac8e47f65d3ae1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a6caaeff32208a7480ba764336689f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a14a6caaeff32208a7480ba764336689f">verify_traversal_order</a> (<a class="el" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html">FillContext</a> &amp;context, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *<a class="el" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>, int depth, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> &amp;line_from, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> &amp;line_to)</td></tr>
<tr class="separator:a14a6caaeff32208a7480ba764336689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29454fb8b1d346b05eb37d19d0c8a4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ae29454fb8b1d346b05eb37d19d0c8a4b">generate_infill_lines_recursive</a> (<a class="el" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html">FillContext</a> &amp;context, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *<a class="el" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>, int address, int depth)</td></tr>
<tr class="separator:ae29454fb8b1d346b05eb37d19d0c8a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab790231e61a09b487d6d06f4ed7360e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab790231e61a09b487d6d06f4ed7360e3">get_nearest_intersection</a> (std::vector&lt; std::pair&lt; <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> *, double &gt; &gt; &amp;intersect_line, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> size_t first_idx)</td></tr>
<tr class="separator:ab790231e61a09b487d6d06f4ed7360e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f035675898b5ecaf6f84d2f73260b94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7f035675898b5ecaf6f84d2f73260b94">create_offset_line</a> (<a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a> offset_line, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;<a class="el" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double scaled_offset)</td></tr>
<tr class="separator:a7f035675898b5ecaf6f84d2f73260b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677dfb88a4d21c1f2299b3c3a5db10b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">mk_rtree_point</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;pt)</td></tr>
<tr class="separator:a677dfb88a4d21c1f2299b3c3a5db10b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af636d8557376a74c109bb61f8ebeb8d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;a, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;b)</td></tr>
<tr class="separator:af636d8557376a74c109bb61f8ebeb8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dfe0f03a13cfd3a7352d3cfa2b8fe7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aa4dfe0f03a13cfd3a7352d3cfa2b8fe7">mk_rtree_seg</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a> &amp;l)</td></tr>
<tr class="separator:aa4dfe0f03a13cfd3a7352d3cfa2b8fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8408e585ff5b07078360b31fd37a95e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a8408e585ff5b07078360b31fd37a95e1">add_hook</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;<a class="el" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double scaled_offset, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a> hook_length, double scaled_trim_distance, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">rtree_t</a> &amp;rtree, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a0913e2e6b7d28032c33cfee03f145fba">Lines</a> &amp;lines_src)</td></tr>
<tr class="separator:a8408e585ff5b07078360b31fd37a95e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b6c3850ee31bb8711301708ef104a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a62b6c3850ee31bb8711301708ef104a9">validate_intersection_t_joint</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;<a class="el" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>)</td></tr>
<tr class="separator:a62b6c3850ee31bb8711301708ef104a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8df2806894ebc7012c77ec366d8525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3e8df2806894ebc7012c77ec366d8525">validate_intersections</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &gt; &amp;intersections)</td></tr>
<tr class="separator:a3e8df2806894ebc7012c77ec366d8525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2f3cac794562525dd4a5ea6cc44fec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#afb2f3cac794562525dd4a5ea6cc44fec">connect_lines_using_hooks</a> (<a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> &amp;&amp;lines, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../db/dc4/class_slic3r_1_1_ex_polygon.html">ExPolygon</a> &amp;boundary, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double spacing, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a> hook_length, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a> hook_length_max)</td></tr>
<tr class="separator:afb2f3cac794562525dd4a5ea6cc44fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2321a9111541715a8960f6b3311d146"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ae2321a9111541715a8960f6b3311d146">has_no_collinear_lines</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> &amp;polylines)</td></tr>
<tr class="separator:ae2321a9111541715a8960f6b3311d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b1d64bf2fbe2f31e06e70cfe6d33cf"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">CubeProperties</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab8b1d64bf2fbe2f31e06e70cfe6d33cf">make_cubes_properties</a> (double max_cube_edge_length, double line_spacing)</td></tr>
<tr class="separator:ab8b1d64bf2fbe2f31e06e70cfe6d33cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112dfa9d85d9dd3843e71c52e493f971"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a112dfa9d85d9dd3843e71c52e493f971">is_overhang_triangle</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;a, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;b, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;c, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;up)</td></tr>
<tr class="separator:a112dfa9d85d9dd3843e71c52e493f971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db146374c8ace3e761fde2bd71e8aea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a9db146374c8ace3e761fde2bd71e8aea">transform_center</a> (<a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *current_cube, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Eigen::Matrix3d &amp;rot)</td></tr>
<tr class="separator:a9db146374c8ace3e761fde2bd71e8aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5a53e88fc9e4f3c11af2874b10c3dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">OctreePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aec5a53e88fc9e4f3c11af2874b10c3dd">build_octree</a> (<a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d0/df2/structindexed__triangle__set.html">indexed_triangle_set</a> &amp;triangle_mesh, <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &gt; &amp;overhang_triangles, <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a> line_spacing, bool support_overhangs_only)</td></tr>
<tr class="separator:aec5a53e88fc9e4f3c11af2874b10c3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a98f3219a051c667f9d93ce9627882a47"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::array&lt; <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a98f3219a051c667f9d93ce9627882a47">child_centers</a></td></tr>
<tr class="separator:a98f3219a051c667f9d93ce9627882a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a3f285c9e9cb0dcb4b21d45f70cf8"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; std::array&lt; int, 8 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#afc7a3f285c9e9cb0dcb4b21d45f70cf8">child_traversal_order</a></td></tr>
<tr class="separator:afc7a3f285c9e9cb0dcb4b21d45f70cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa491a87bb43c2acacebd4bd7a77cff67"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aa491a87bb43c2acacebd4bd7a77cff67">octree_rot</a> [3] = { 5.0 * <a class="el" href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 4.0, <a class="el" href="../../d3/dfb/namespace_slic3r_1_1_geometry.html#a345f6f1e6238a364b20bdabac88a8314">Geometry::deg2rad</a>(215.264), <a class="el" href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 6.0 }</td></tr>
<tr class="separator:aa491a87bb43c2acacebd4bd7a77cff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties" id="da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties"></a>
<h2 class="memtitle"><span class="permalink"><a href="#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">&#9670;&#160;</a></span>Slic3r::FillAdaptive::CubeProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Slic3r::FillAdaptive::CubeProperties</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a9d4e791d04bd48d0172989f12428e3ea" name="a9d4e791d04bd48d0172989f12428e3ea"></a>double</td>
<td class="fieldname">
diagonal_length</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aeb308403d196d1a9fb441fa326d424d7" name="aeb308403d196d1a9fb441fa326d424d7"></a>double</td>
<td class="fieldname">
edge_length</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a269600f42bae6a5d43733264e6411cba" name="a269600f42bae6a5d43733264e6411cba"></a>double</td>
<td class="fieldname">
height</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ab51a5b399081d7521785842595092fcd" name="ab51a5b399081d7521785842595092fcd"></a>double</td>
<td class="fieldname">
line_xy_distance</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac5ec8f0fe702d24a5dab262a4131abd5" name="ac5ec8f0fe702d24a5dab262a4131abd5"></a>double</td>
<td class="fieldname">
line_z_distance</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a26cd64cc9ecd14940e8bd93de0b57326" name="a26cd64cc9ecd14940e8bd93de0b57326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cd64cc9ecd14940e8bd93de0b57326">&#9670;&#160;</a></span>OctreePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt; <a class="el" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Octree</a>, <a class="el" href="../../df/dc6/struct_slic3r_1_1_fill_adaptive_1_1_octree_deleter.html">OctreeDeleter</a> &gt; <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">Slic3r::FillAdaptive::OctreePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bea6f8de479db81e6d18ec53d5f73b6" name="a4bea6f8de479db81e6d18ec53d5f73b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bea6f8de479db81e6d18ec53d5f73b6">&#9670;&#160;</a></span>rtree_point_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">Slic3r::FillAdaptive::rtree_point_t</a> = typedef bgm::point&lt;float, 2, boost::geometry::cs::cartesian&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c6a11139ccb39e953a4f28a21ea0961" name="a7c6a11139ccb39e953a4f28a21ea0961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6a11139ccb39e953a4f28a21ea0961">&#9670;&#160;</a></span>rtree_segment_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">Slic3r::FillAdaptive::rtree_segment_t</a> = typedef bgm::segment&lt;<a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ef2163df60632bf830aa7ee39d43b7" name="ad5ef2163df60632bf830aa7ee39d43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ef2163df60632bf830aa7ee39d43b7">&#9670;&#160;</a></span>rtree_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">Slic3r::FillAdaptive::rtree_t</a> = typedef bgi::rtree&lt;std::pair&lt;<a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a>, size_t&gt;, bgi::rstar&lt;16, 4&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79a5a8767b9bbd4ad7389906cccac872" name="a79a5a8767b9bbd4ad7389906cccac872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a5a8767b9bbd4ad7389906cccac872">&#9670;&#160;</a></span>adaptive_fill_line_spacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Slic3r::FillAdaptive::adaptive_fill_line_spacing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/d87/class_slic3r_1_1_print_object.html">PrintObject</a> &amp;&#160;</td>
          <td class="paramname"><em>print_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  277</span>{</div>
<div class="line"><span class="lineno">  278</span>    <span class="comment">// Output, spacing for icAdaptiveCubic and icSupportCubic</span></div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordtype">double</span>  adaptive_line_spacing = 0.;</div>
<div class="line"><span class="lineno">  280</span>    <span class="keywordtype">double</span>  support_line_spacing = 0.;</div>
<div class="line"><span class="lineno">  281</span> </div>
<div class="line"><span class="lineno">  282</span>    <span class="keyword">enum class</span> Tristate {</div>
<div class="line"><span class="lineno">  283</span>        <a class="code hl_enumvalue" href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309a93cba07454f06a4a960172bbd6e2a435">Yes</a>,</div>
<div class="line"><span class="lineno">  284</span>        <a class="code hl_enumvalue" href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309abafd7322c6e97d25b6299b5d6fe8920b">No</a>,</div>
<div class="line"><span class="lineno">  285</span>        Maybe</div>
<div class="line"><span class="lineno">  286</span>    };</div>
<div class="line"><span class="lineno">  287</span>    <span class="keyword">struct </span>RegionFillData {</div>
<div class="line"><span class="lineno">  288</span>        Tristate        has_adaptive_infill;</div>
<div class="line"><span class="lineno">  289</span>        Tristate        has_support_infill;</div>
<div class="line"><span class="lineno">  290</span>        <span class="keywordtype">double</span>          density;</div>
<div class="line"><span class="lineno">  291</span>        <span class="keywordtype">double</span>          extrusion_width;</div>
<div class="line"><span class="lineno">  292</span>    };</div>
<div class="line"><span class="lineno">  293</span>    std::vector&lt;RegionFillData&gt; region_fill_data;</div>
<div class="line"><span class="lineno">  294</span>    region_fill_data.reserve(print_object.<a class="code hl_function" href="../../de/d87/class_slic3r_1_1_print_object.html#a60d2f960358e1f2d2607e929d6ddc5fd">num_printing_regions</a>());</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordtype">bool</span>                       build_octree                   = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  296</span>    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;nozzle_diameters               = print_object.<a class="code hl_function" href="../../d6/d0d/class_slic3r_1_1_print_object_base_with_state.html#aac73b24e3c0c005584ab03214116041e">print</a>()-&gt;<a class="code hl_function" href="../../d5/d8f/class_slic3r_1_1_print.html#af1937a680d19c7dd8d3c24e5ff7332b8">config</a>().nozzle_diameter.values;</div>
<div class="line"><span class="lineno">  297</span>    <span class="keywordtype">double</span>                     max_nozzle_diameter            = *std::max_element(nozzle_diameters.begin(), nozzle_diameters.end());</div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordtype">double</span>                     default_infill_extrusion_width = Flow::auto_extrusion_width(FlowRole::frInfill, <span class="keywordtype">float</span>(max_nozzle_diameter));</div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> region_id = 0; region_id &lt; print_object.<a class="code hl_function" href="../../de/d87/class_slic3r_1_1_print_object.html#a60d2f960358e1f2d2607e929d6ddc5fd">num_printing_regions</a>(); ++ region_id) {</div>
<div class="line"><span class="lineno">  300</span>        <span class="keyword">const</span> PrintRegionConfig &amp;config                 = print_object.<a class="code hl_function" href="../../de/d87/class_slic3r_1_1_print_object.html#aa178d87b88091cceb67db31bceae7971">printing_region</a>(region_id).<a class="code hl_function" href="../../d4/df8/class_slic3r_1_1_print_region.html#a8d40c7f03e5ac246db3dfa4e82042e5e">config</a>();</div>
<div class="line"><span class="lineno">  301</span>        <span class="keywordtype">bool</span>                     nonempty               = config.fill_density &gt; 0;</div>
<div class="line"><span class="lineno">  302</span>        <span class="keywordtype">bool</span>                     has_adaptive_infill    = nonempty &amp;&amp; config.fill_pattern == ipAdaptiveCubic;</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordtype">bool</span>                     has_support_infill     = nonempty &amp;&amp; config.fill_pattern == ipSupportCubic;</div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordtype">double</span>                   infill_extrusion_width = config.infill_extrusion_width.percent ? default_infill_extrusion_width * 0.01 * config.infill_extrusion_width : config.infill_extrusion_width;</div>
<div class="line"><span class="lineno">  305</span>        region_fill_data.push_back(RegionFillData({</div>
<div class="line"><span class="lineno">  306</span>            has_adaptive_infill ? Tristate::Maybe : Tristate::No,</div>
<div class="line"><span class="lineno">  307</span>            has_support_infill ? Tristate::Maybe : Tristate::No,</div>
<div class="line"><span class="lineno">  308</span>            config.fill_density,</div>
<div class="line"><span class="lineno">  309</span>            infill_extrusion_width != 0. ? infill_extrusion_width : default_infill_extrusion_width</div>
<div class="line"><span class="lineno">  310</span>        }));</div>
<div class="line"><span class="lineno">  311</span>        <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aec5a53e88fc9e4f3c11af2874b10c3dd">build_octree</a> |= has_adaptive_infill || has_support_infill;</div>
<div class="line"><span class="lineno">  312</span>    }</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span>    <span class="keywordflow">if</span> (build_octree) {</div>
<div class="line"><span class="lineno">  315</span>        <span class="comment">// Compute the average of above parameters over all layers</span></div>
<div class="line"><span class="lineno">  316</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Layer *layer : print_object.layers())</div>
<div class="line"><span class="lineno">  317</span>            for (size_t region_id = 0; region_id &lt; layer-&gt;regions().size(); ++ region_id) {</div>
<div class="line"><span class="lineno">  318</span>                RegionFillData &amp;rd = region_fill_data[region_id];</div>
<div class="line"><span class="lineno">  319</span>                <span class="keywordflow">if</span> (rd.has_adaptive_infill == Tristate::Maybe &amp;&amp; ! layer-&gt;regions()[region_id]-&gt;fill_surfaces().empty())</div>
<div class="line"><span class="lineno">  320</span>                    rd.has_adaptive_infill = Tristate::Yes;</div>
<div class="line"><span class="lineno">  321</span>                <span class="keywordflow">if</span> (rd.has_support_infill == Tristate::Maybe &amp;&amp; ! layer-&gt;regions()[region_id]-&gt;fill_surfaces().empty())</div>
<div class="line"><span class="lineno">  322</span>                    rd.has_support_infill = Tristate::Yes;</div>
<div class="line"><span class="lineno">  323</span>            }</div>
<div class="line"><span class="lineno">  324</span> </div>
<div class="line"><span class="lineno">  325</span>        <span class="keywordtype">double</span>  adaptive_fill_density           = 0.;</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordtype">double</span>  adaptive_infill_extrusion_width = 0.;</div>
<div class="line"><span class="lineno">  327</span>        <span class="keywordtype">int</span>     adaptive_cnt                    = 0;</div>
<div class="line"><span class="lineno">  328</span>        <span class="keywordtype">double</span>  support_fill_density            = 0.;</div>
<div class="line"><span class="lineno">  329</span>        <span class="keywordtype">double</span>  support_infill_extrusion_width  = 0.;</div>
<div class="line"><span class="lineno">  330</span>        <span class="keywordtype">int</span>     support_cnt                     = 0;</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> RegionFillData &amp;rd : region_fill_data) {</div>
<div class="line"><span class="lineno">  333</span>            <span class="keywordflow">if</span> (rd.has_adaptive_infill == Tristate::Yes) {</div>
<div class="line"><span class="lineno">  334</span>                adaptive_fill_density           += rd.density;</div>
<div class="line"><span class="lineno">  335</span>                adaptive_infill_extrusion_width += rd.extrusion_width;</div>
<div class="line"><span class="lineno">  336</span>                ++ adaptive_cnt;</div>
<div class="line"><span class="lineno">  337</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rd.has_support_infill == Tristate::Yes) {</div>
<div class="line"><span class="lineno">  338</span>                support_fill_density           += rd.density;</div>
<div class="line"><span class="lineno">  339</span>                support_infill_extrusion_width += rd.extrusion_width;</div>
<div class="line"><span class="lineno">  340</span>                ++ support_cnt;</div>
<div class="line"><span class="lineno">  341</span>            }</div>
<div class="line"><span class="lineno">  342</span>        }</div>
<div class="line"><span class="lineno">  343</span> </div>
<div class="line"><span class="lineno">  344</span>        <span class="keyword">auto</span> to_line_spacing = [](<span class="keywordtype">int</span> cnt, <span class="keywordtype">double</span> density, <span class="keywordtype">double</span> extrusion_width) {</div>
<div class="line"><span class="lineno">  345</span>            <span class="keywordflow">if</span> (cnt) {</div>
<div class="line"><span class="lineno">  346</span>                density         /= double(cnt);</div>
<div class="line"><span class="lineno">  347</span>                extrusion_width /= double(cnt);</div>
<div class="line"><span class="lineno">  348</span>                <span class="keywordflow">return</span> extrusion_width / ((density / 100.0f) * 0.333333333f);</div>
<div class="line"><span class="lineno">  349</span>            } <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  350</span>                <span class="keywordflow">return</span> 0.;</div>
<div class="line"><span class="lineno">  351</span>        };</div>
<div class="line"><span class="lineno">  352</span>        adaptive_line_spacing = to_line_spacing(adaptive_cnt, adaptive_fill_density, adaptive_infill_extrusion_width);</div>
<div class="line"><span class="lineno">  353</span>        support_line_spacing  = to_line_spacing(support_cnt, support_fill_density, support_infill_extrusion_width);</div>
<div class="line"><span class="lineno">  354</span>    }</div>
<div class="line"><span class="lineno">  355</span> </div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">return</span> std::make_pair(adaptive_line_spacing, support_line_spacing);</div>
<div class="line"><span class="lineno">  357</span>}</div>
<div class="ttc" id="aclass_slic3r_1_1_print_html_af1937a680d19c7dd8d3c24e5ff7332b8"><div class="ttname"><a href="../../d5/d8f/class_slic3r_1_1_print.html#af1937a680d19c7dd8d3c24e5ff7332b8">Slic3r::Print::config</a></div><div class="ttdeci">const PrintConfig &amp; config() const</div><div class="ttdef"><b>Definition</b> Print.hpp:597</div></div>
<div class="ttc" id="aclass_slic3r_1_1_print_object_base_with_state_html_aac73b24e3c0c005584ab03214116041e"><div class="ttname"><a href="../../d6/d0d/class_slic3r_1_1_print_object_base_with_state.html#aac73b24e3c0c005584ab03214116041e">Slic3r::PrintObjectBaseWithState::print</a></div><div class="ttdeci">PrintType * print()</div><div class="ttdef"><b>Definition</b> PrintBase.hpp:735</div></div>
<div class="ttc" id="aclass_slic3r_1_1_print_object_html_a60d2f960358e1f2d2607e929d6ddc5fd"><div class="ttname"><a href="../../de/d87/class_slic3r_1_1_print_object.html#a60d2f960358e1f2d2607e929d6ddc5fd">Slic3r::PrintObject::num_printing_regions</a></div><div class="ttdeci">size_t num_printing_regions() const</div><div class="ttdef"><b>Definition</b> Print.hpp:312</div></div>
<div class="ttc" id="aclass_slic3r_1_1_print_object_html_aa178d87b88091cceb67db31bceae7971"><div class="ttname"><a href="../../de/d87/class_slic3r_1_1_print_object.html#aa178d87b88091cceb67db31bceae7971">Slic3r::PrintObject::printing_region</a></div><div class="ttdeci">const PrintRegion &amp; printing_region(size_t idx) const</div><div class="ttdef"><b>Definition</b> Print.hpp:313</div></div>
<div class="ttc" id="aclass_slic3r_1_1_print_region_html_a8d40c7f03e5ac246db3dfa4e82042e5e"><div class="ttname"><a href="../../d4/df8/class_slic3r_1_1_print_region.html#a8d40c7f03e5ac246db3dfa4e82042e5e">Slic3r::PrintRegion::config</a></div><div class="ttdeci">const PrintRegionConfig &amp; config() const</div><div class="ttdef"><b>Definition</b> Print.hpp:87</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_aec5a53e88fc9e4f3c11af2874b10c3dd"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aec5a53e88fc9e4f3c11af2874b10c3dd">Slic3r::FillAdaptive::build_octree</a></div><div class="ttdeci">OctreePtr build_octree(const indexed_triangle_set &amp;triangle_mesh, const std::vector&lt; Vec3d &gt; &amp;overhang_triangles, coordf_t line_spacing, bool support_overhangs_only)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:1465</div></div>
<div class="ttc" id="anamespace_slic3r_html_abc7114acd0870edd5d927289d0810309a93cba07454f06a4a960172bbd6e2a435"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309a93cba07454f06a4a960172bbd6e2a435">Slic3r::ApplySafetyOffset::Yes</a></div><div class="ttdeci">@ Yes</div></div>
<div class="ttc" id="anamespace_slic3r_html_abc7114acd0870edd5d927289d0810309abafd7322c6e97d25b6299b5d6fe8920b"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309abafd7322c6e97d25b6299b5d6fe8920b">Slic3r::ApplySafetyOffset::No</a></div><div class="ttdeci">@ No</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00018">Slic3r::Flow::auto_extrusion_width()</a>, <a class="el" href="../../#l01465">build_octree()</a>, <a class="el" href="../../#l00087">Slic3r::PrintRegion::config()</a>, <a class="el" href="../../#l00597">Slic3r::Print::config()</a>, <a class="el" href="../../#l00019">Slic3r::frInfill</a>, <a class="el" href="../../de/db8/namespace_slic3r.html#a2edfa17e20a5dc7ab5b673377067cd3d">Slic3r::infill_extrusion_width()</a>, <a class="el" href="../../#l00062">Slic3r::ipAdaptiveCubic</a>, <a class="el" href="../../#l00062">Slic3r::ipSupportCubic</a>, <a class="el" href="../../#l00247">Slic3r::PrintObject::layers()</a>, <a class="el" href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309abafd7322c6e97d25b6299b5d6fe8920b">Slic3r::No</a>, <a class="el" href="../../#l00312">Slic3r::PrintObject::num_printing_regions()</a>, <a class="el" href="../../#l00735">Slic3r::PrintObjectBaseWithState&lt; PrintType, PrintObjectStepEnumType, COUNT &gt;::print()</a>, <a class="el" href="../../#l00313">Slic3r::PrintObject::printing_region()</a>, <a class="el" href="../../#l00840">Slic3r::PrintRegionConfig</a>, and <a class="el" href="../../de/db8/namespace_slic3r.html#abc7114acd0870edd5d927289d0810309a93cba07454f06a4a960172bbd6e2a435">Slic3r::Yes</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a79a5a8767b9bbd4ad7389906cccac872_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a8408e585ff5b07078360b31fd37a95e1" name="a8408e585ff5b07078360b31fd37a95e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8408e585ff5b07078360b31fd37a95e1">&#9670;&#160;</a></span>add_hook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> Slic3r::FillAdaptive::add_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double&#160;</td>
          <td class="paramname"><em>scaled_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a>&#160;</td>
          <td class="paramname"><em>hook_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaled_trim_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">rtree_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a0913e2e6b7d28032c33cfee03f145fba">Lines</a> &amp;&#160;</td>
          <td class="paramname"><em>lines_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  673</span>{</div>
<div class="line"><span class="lineno">  674</span>    <span class="keywordflow">if</span> (hook_length &lt; <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>)</div>
<div class="line"><span class="lineno">  675</span>        <span class="comment">// Ignore open hooks.</span></div>
<div class="line"><span class="lineno">  676</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  679</span>    {</div>
<div class="line"><span class="lineno">  680</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a>  v  = (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;b - <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  681</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a>  va = (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_point - <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  682</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a> = v.squaredNorm();  <span class="comment">// avoid a sqrt</span></div>
<div class="line"><span class="lineno">  683</span>        assert(l2 &gt; 0.);</div>
<div class="line"><span class="lineno">  684</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> t  = va.dot(v) / <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a>;</div>
<div class="line"><span class="lineno">  685</span>        assert(t &gt; 0. &amp;&amp; t &lt; 1.);</div>
<div class="line"><span class="lineno">  686</span>        <span class="keyword">const</span> <span class="keywordtype">double</span>          d  = (t * v - va).norm();</div>
<div class="line"><span class="lineno">  687</span>        assert(d &lt; 1000.);</div>
<div class="line"><span class="lineno">  688</span>    }</div>
<div class="line"><span class="lineno">  689</span><span class="preprocessor">#endif </span><span class="comment">// NDEBUG</span></div>
<div class="line"><span class="lineno">  690</span> </div>
<div class="line"><span class="lineno">  691</span>    <span class="comment">// Trim the hook start by the infill line it will connect to.</span></div>
<div class="line"><span class="lineno">  692</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> hook_start;</div>
<div class="line"><span class="lineno">  693</span> </div>
<div class="line"><span class="lineno">  694</span>    [[maybe_unused]] <span class="keywordtype">bool</span> intersection_found = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_line-&gt;intersection(</div>
<div class="line"><span class="lineno">  695</span>        create_offset_line(*<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line, intersection, scaled_offset),</div>
<div class="line"><span class="lineno">  696</span>        &amp;hook_start);</div>
<div class="line"><span class="lineno">  697</span>    assert(intersection_found);</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    std::optional&lt;Line&gt; other_hook = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.other_hook();</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>    <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a>   hook_vector_norm = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;vector().cast&lt;<span class="keywordtype">double</span>&gt;().normalized();</div>
<div class="line"><span class="lineno">  702</span>    <span class="comment">// hook_vector is extended by the thickness of the infill line, so that a collision is found against</span></div>
<div class="line"><span class="lineno">  703</span>    <span class="comment">// the infill centerline to be later trimmed by the thickened line.</span></div>
<div class="line"><span class="lineno">  704</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a>  hook_vector      = ((hook_length + 1.16 * scaled_trim_distance) * hook_vector_norm).cast&lt;<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>&gt;();</div>
<div class="line"><span class="lineno">  705</span>    <a class="code hl_class" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a>    hook_forward(hook_start, hook_start + hook_vector);</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>    <span class="keyword">auto</span> filter_itself = [&amp;<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>, &amp;lines_src](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item) { <span class="keywordflow">return</span> item.second != (<span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> int)(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_line - lines_src.data()); };</div>
<div class="line"><span class="lineno">  708</span> </div>
<div class="line"><span class="lineno">  709</span>    std::vector&lt;std::pair&lt;rtree_segment_t, size_t&gt;&gt; hook_intersections;</div>
<div class="line"><span class="lineno">  710</span>    rtree.query(bgi::intersects(mk_rtree_seg(hook_forward)) &amp;&amp; bgi::satisfies(filter_itself), std::back_inserter(hook_intersections));</div>
<div class="line"><span class="lineno">  711</span>    <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> self_intersection_point;</div>
<div class="line"><span class="lineno">  712</span>    <span class="keywordtype">bool</span>  self_intersection = other_hook &amp;&amp; other_hook-&gt;intersection(hook_forward, &amp;self_intersection_point);</div>
<div class="line"><span class="lineno">  713</span> </div>
<div class="line"><span class="lineno">  714</span>    <span class="comment">// Find closest intersection of a line segment starting with pt pointing in dir</span></div>
<div class="line"><span class="lineno">  715</span>    <span class="comment">// with any of the hook_intersections, returns Euclidian distance.</span></div>
<div class="line"><span class="lineno">  716</span>    <span class="comment">// dir is normalized.</span></div>
<div class="line"><span class="lineno">  717</span>    <span class="keyword">auto</span> max_hook_length = [hook_length, scaled_trim_distance, &amp;lines_src](</div>
<div class="line"><span class="lineno">  718</span>        <span class="keyword">const</span> Vec2d &amp;pt, <span class="keyword">const</span> Vec2d &amp;dir,</div>
<div class="line"><span class="lineno">  719</span>        <span class="keyword">const</span> std::vector&lt;std::pair&lt;rtree_segment_t, size_t&gt;&gt; &amp;hook_intersections,</div>
<div class="line"><span class="lineno">  720</span>        <span class="keywordtype">bool</span> self_intersection, <span class="keyword">const</span> std::optional&lt;Line&gt; &amp;self_intersection_line, <span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;self_intersection_point) {</div>
<div class="line"><span class="lineno">  721</span>        <span class="comment">// No hook is longer than hook_length, there shouldn&#39;t be any intersection closer than that.</span></div>
<div class="line"><span class="lineno">  722</span>        <span class="keyword">auto</span> max_length = hook_length;</div>
<div class="line"><span class="lineno">  723</span>        <span class="keyword">auto</span> update_max_length = [&amp;max_length](<span class="keywordtype">double</span> d) {</div>
<div class="line"><span class="lineno">  724</span>            <span class="keywordflow">if</span> (d &lt; max_length)</div>
<div class="line"><span class="lineno">  725</span>                max_length = d;</div>
<div class="line"><span class="lineno">  726</span>        };</div>
<div class="line"><span class="lineno">  727</span>        <span class="comment">// Shift the trimming point away from the colliding thick line.</span></div>
<div class="line"><span class="lineno">  728</span>        <span class="keyword">auto</span> shift_from_thick_line = [&amp;dir, scaled_trim_distance](<span class="keyword">const</span> <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>&amp; dir2) {</div>
<div class="line"><span class="lineno">  729</span>            <span class="keywordflow">return</span> scaled_trim_distance * std::abs(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a2cd973ab8e7af30bd57721dfc2859b8f">cross2</a>(dir, dir2.normalized()));</div>
<div class="line"><span class="lineno">  730</span>        };</div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;hook_intersection : hook_intersections) {</div>
<div class="line"><span class="lineno">  733</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a> &amp;<a class="code hl_function" href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a> = hook_intersection.first;</div>
<div class="line"><span class="lineno">  734</span>            <span class="comment">// Segment start and end points, segment vector.</span></div>
<div class="line"><span class="lineno">  735</span>            <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> pt2(bg::get&lt;0, 0&gt;(<a class="code hl_function" href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a>), bg::get&lt;0, 1&gt;(<a class="code hl_function" href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a>));</div>
<div class="line"><span class="lineno">  736</span>            <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> dir2 = <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>(bg::get&lt;1, 0&gt;(<a class="code hl_function" href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a>), bg::get&lt;1, 1&gt;(<a class="code hl_function" href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a>)) - pt2;</div>
<div class="line"><span class="lineno">  737</span>            <span class="comment">// Find intersection of (pt, dir) with (pt2, dir2), where dir is normalized.</span></div>
<div class="line"><span class="lineno">  738</span>            <span class="keywordtype">double</span> denom = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a2cd973ab8e7af30bd57721dfc2859b8f">cross2</a>(dir, dir2);</div>
<div class="line"><span class="lineno">  739</span>            assert(std::abs(denom) &gt; <a class="code hl_variable" href="../../dd/d47/libslic3r_8h.html#a75f355966e0a97665eaf5a4c79baa7af">EPSILON</a>);</div>
<div class="line"><span class="lineno">  740</span>            <span class="keywordtype">double</span> t = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a2cd973ab8e7af30bd57721dfc2859b8f">cross2</a>(pt2 - pt, dir2) / denom;</div>
<div class="line"><span class="lineno">  741</span>            <span class="keywordflow">if</span> (hook_intersection.second &lt; lines_src.size())</div>
<div class="line"><span class="lineno">  742</span>                <span class="comment">// Trimming by another infill line. Reduce overlap.</span></div>
<div class="line"><span class="lineno">  743</span>                t -= shift_from_thick_line(dir2);</div>
<div class="line"><span class="lineno">  744</span>            update_max_length(t);</div>
<div class="line"><span class="lineno">  745</span>        }</div>
<div class="line"><span class="lineno">  746</span>        <span class="keywordflow">if</span> (self_intersection) {</div>
<div class="line"><span class="lineno">  747</span>            <span class="keywordtype">double</span> t = (self_intersection_point.cast&lt;<span class="keywordtype">double</span>&gt;() - pt).dot(dir) - shift_from_thick_line((*self_intersection_line).vector().cast&lt;<span class="keywordtype">double</span>&gt;());</div>
<div class="line"><span class="lineno">  748</span>            max_length = std::min(max_length, t);</div>
<div class="line"><span class="lineno">  749</span>        }</div>
<div class="line"><span class="lineno">  750</span>        <span class="keywordflow">return</span> std::max(0., max_length);</div>
<div class="line"><span class="lineno">  751</span>    };</div>
<div class="line"><span class="lineno">  752</span> </div>
<div class="line"><span class="lineno">  753</span>    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>  hook_startf              = hook_start.cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno">  754</span>    <span class="keywordtype">double</span> hook_forward_max_length  = max_hook_length(hook_startf, hook_vector_norm, hook_intersections, self_intersection, other_hook, self_intersection_point);</div>
<div class="line"><span class="lineno">  755</span>    <span class="keywordtype">double</span> hook_backward_max_length = 0.;</div>
<div class="line"><span class="lineno">  756</span>    <span class="keywordflow">if</span> (hook_forward_max_length &lt; hook_length - <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>) {</div>
<div class="line"><span class="lineno">  757</span>        <span class="comment">// Try the other side.</span></div>
<div class="line"><span class="lineno">  758</span>        hook_intersections.clear();</div>
<div class="line"><span class="lineno">  759</span>        Line hook_backward(hook_start, hook_start - hook_vector);</div>
<div class="line"><span class="lineno">  760</span>        rtree.query(bgi::intersects(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(hook_backward)) &amp;&amp; bgi::satisfies(filter_itself), std::back_inserter(hook_intersections));</div>
<div class="line"><span class="lineno">  761</span>        self_intersection = other_hook &amp;&amp; other_hook-&gt;intersection(hook_backward, &amp;self_intersection_point);</div>
<div class="line"><span class="lineno">  762</span>        hook_backward_max_length = max_hook_length(hook_startf, - hook_vector_norm, hook_intersections, self_intersection, other_hook, self_intersection_point);</div>
<div class="line"><span class="lineno">  763</span>    }</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>    <span class="comment">// Take the longer hook.</span></div>
<div class="line"><span class="lineno">  766</span>    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> hook_dir = (hook_forward_max_length &gt; hook_backward_max_length ? hook_forward_max_length : - hook_backward_max_length) * hook_vector_norm;</div>
<div class="line"><span class="lineno">  767</span>    <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> hook_end = hook_start + hook_dir.cast&lt;<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>&gt;();</div>
<div class="line"><span class="lineno">  768</span> </div>
<div class="line"><span class="lineno">  769</span>    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#aee987cbd1647986a9ac92226daffa4d7">Points</a> &amp;pl = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl-&gt;points;</div>
<div class="line"><span class="lineno">  770</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.front) {</div>
<div class="line"><span class="lineno">  771</span>        pl.front() = hook_start;</div>
<div class="line"><span class="lineno">  772</span>        pl.emplace(pl.begin(), hook_end);</div>
<div class="line"><span class="lineno">  773</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  774</span>        pl.back() = hook_start;</div>
<div class="line"><span class="lineno">  775</span>        pl.emplace_back(hook_end);</div>
<div class="line"><span class="lineno">  776</span>    }</div>
<div class="line"><span class="lineno">  777</span>}</div>
<div class="ttc" id="a_block_methods_8h_html_a3c8d2bfe6f857a2a270b78759487e3a8"><div class="ttname"><a href="../../d6/d4f/_block_methods_8h.html#a3c8d2bfe6f857a2a270b78759487e3a8">segment</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC SegmentReturnType segment(Index start, Index n)</div><div class="ttdoc">This is the const version of segment(Index,Index).</div><div class="ttdef"><b>Definition</b> BlockMethods.h:888</div></div>
<div class="ttc" id="aclass_eigen_1_1_matrix_html"><div class="ttname"><a href="../../d2/d2d/class_eigen_1_1_matrix.html">Eigen::Matrix&lt; double, 2, 1, Eigen::DontAlign &gt;</a></div></div>
<div class="ttc" id="aclass_slic3r_1_1_line_html"><div class="ttname"><a href="../../d6/d3b/class_slic3r_1_1_line.html">Slic3r::Line</a></div><div class="ttdef"><b>Definition</b> Line.hpp:155</div></div>
<div class="ttc" id="aclass_slic3r_1_1_point_html"><div class="ttname"><a href="../../d6/dec/class_slic3r_1_1_point.html">Slic3r::Point</a></div><div class="ttdef"><b>Definition</b> Point.hpp:158</div></div>
<div class="ttc" id="alibslic3r_8h_html_a57f3510310e75de35abd65c9650b49f7"><div class="ttname"><a href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a></div><div class="ttdeci">#define SCALED_EPSILON</div><div class="ttdef"><b>Definition</b> libslic3r.h:71</div></div>
<div class="ttc" id="alibslic3r_8h_html_a75f355966e0a97665eaf5a4c79baa7af"><div class="ttname"><a href="../../dd/d47/libslic3r_8h.html#a75f355966e0a97665eaf5a4c79baa7af">EPSILON</a></div><div class="ttdeci">static constexpr double EPSILON</div><div class="ttdef"><b>Definition</b> libslic3r.h:51</div></div>
<div class="ttc" id="alibslic3r_8h_html_a8a7f69c27280e7542b2d1fd979af4545"><div class="ttname"><a href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a></div><div class="ttdeci">int32_t coord_t</div><div class="ttdef"><b>Definition</b> libslic3r.h:39</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a7c6a11139ccb39e953a4f28a21ea0961"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">Slic3r::FillAdaptive::rtree_segment_t</a></div><div class="ttdeci">bgm::segment&lt; rtree_point_t &gt; rtree_segment_t</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:655</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_af636d8557376a74c109bb61f8ebeb8d3"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">Slic3r::FillAdaptive::mk_rtree_seg</a></div><div class="ttdeci">static rtree_segment_t mk_rtree_seg(const Point &amp;a, const Point &amp;b)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:661</div></div>
<div class="ttc" id="anamespace_slic3r_html_a1e045f56a994b8cd4a5b203626cd8272"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">Slic3r::l2</a></div><div class="ttdeci">T l2(const boost::geometry::model::d2::point_xy&lt; T &gt; &amp;v)</div><div class="ttdef"><b>Definition</b> ExtrusionSimulator.cpp:166</div></div>
<div class="ttc" id="anamespace_slic3r_html_a2cd973ab8e7af30bd57721dfc2859b8f"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a2cd973ab8e7af30bd57721dfc2859b8f">Slic3r::cross2</a></div><div class="ttdeci">Derived::Scalar cross2(const Eigen::MatrixBase&lt; Derived &gt; &amp;v1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;v2)</div><div class="ttdef"><b>Definition</b> Point.hpp:93</div></div>
<div class="ttc" id="anamespace_slic3r_html_a40e8e384542f32f8150cabd3db031651"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Slic3r::Vec2d</a></div><div class="ttdeci">Eigen::Matrix&lt; double, 2, 1, Eigen::DontAlign &gt; Vec2d</div><div class="ttdef"><b>Definition</b> Point.hpp:51</div></div>
<div class="ttc" id="anamespace_slic3r_html_a57c612ab2aa7dd29f1e7ece220e3af82"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">Slic3r::intersection</a></div><div class="ttdeci">Slic3r::Polygons intersection(const Slic3r::Polygon &amp;subject, const Slic3r::Polygon &amp;clip, ApplySafetyOffset do_safety_offset)</div><div class="ttdef"><b>Definition</b> ClipperUtils.cpp:686</div></div>
<div class="ttc" id="anamespace_slic3r_html_aee987cbd1647986a9ac92226daffa4d7"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#aee987cbd1647986a9ac92226daffa4d7">Slic3r::Points</a></div><div class="ttdeci">std::vector&lt; Point, PointsAllocator&lt; Point &gt; &gt; Points</div><div class="ttdef"><b>Definition</b> Point.hpp:58</div></div>
<div class="ttc" id="apoint__areas_8cpp_html_a6a2f109ab3e0aba2f61e7d28188c3660"><div class="ttname"><a href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a></div><div class="ttdeci">Kernel::Point_2 Point</div><div class="ttdef"><b>Definition</b> point_areas.cpp:20</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00641">create_offset_line()</a>, <a class="el" href="../../#l00093">Slic3r::cross2()</a>, <a class="el" href="../../#l00051">EPSILON</a>, <a class="el" href="../../#l00686">Slic3r::intersection()</a>, <a class="el" href="../../#l00166">Slic3r::l2()</a>, <a class="el" href="../../#l00661">mk_rtree_seg()</a>, <a class="el" href="../../#l00071">SCALED_EPSILON</a>, and <a class="el" href="../../#l00888">segment()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a8408e585ff5b07078360b31fd37a95e1_cgraph.svg" width="100%" height="597"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a8408e585ff5b07078360b31fd37a95e1_icgraph.svg" width="379" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aec5a53e88fc9e4f3c11af2874b10c3dd" name="aec5a53e88fc9e4f3c11af2874b10c3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5a53e88fc9e4f3c11af2874b10c3dd">&#9670;&#160;</a></span>build_octree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">FillAdaptive::OctreePtr</a> Slic3r::FillAdaptive::build_octree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d0/df2/structindexed__triangle__set.html">indexed_triangle_set</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>overhang_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a>&#160;</td>
          <td class="paramname"><em>line_spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>support_overhangs_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1473</span>{</div>
<div class="line"><span class="lineno"> 1474</span>    assert(line_spacing &gt; 0);</div>
<div class="line"><span class="lineno"> 1475</span>    assert(! std::isnan(line_spacing));</div>
<div class="line"><span class="lineno"> 1476</span> </div>
<div class="line"><span class="lineno"> 1477</span>    <a class="code hl_class" href="../../da/d00/class_slic3r_1_1_bounding_box3_base.html">BoundingBox3Base&lt;Vec3f&gt;</a>     bbox(triangle_mesh.<a class="code hl_variable" href="../../d0/df2/structindexed__triangle__set.html#a86d0433f7db7abf0f94c7e3d1302b09c">vertices</a>);</div>
<div class="line"><span class="lineno"> 1478</span>    <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a>                       cube_center      = bbox.center().cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno"> 1479</span>    std::vector&lt;CubeProperties&gt; cubes_properties = <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab8b1d64bf2fbe2f31e06e70cfe6d33cf">make_cubes_properties</a>(<span class="keywordtype">double</span>(bbox.size().maxCoeff()), line_spacing);</div>
<div class="line"><span class="lineno"> 1480</span>    <span class="keyword">auto</span>                        octree           = <a class="code hl_typedef" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">OctreePtr</a>(<span class="keyword">new</span> <a class="code hl_struct" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Octree</a>(cube_center, cubes_properties));</div>
<div class="line"><span class="lineno"> 1481</span> </div>
<div class="line"><span class="lineno"> 1482</span>    <span class="keywordflow">if</span> (cubes_properties.size() &gt; 1) {</div>
<div class="line"><span class="lineno"> 1483</span>        <a class="code hl_struct" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Octree</a> *octree_ptr = octree.get();</div>
<div class="line"><span class="lineno"> 1484</span>        <span class="keywordtype">double</span> edge_length_half = 0.5 * cubes_properties.back().edge_length;</div>
<div class="line"><span class="lineno"> 1485</span>        <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a>  diag_half(edge_length_half, edge_length_half, edge_length_half);</div>
<div class="line"><span class="lineno"> 1486</span>        <span class="keywordtype">int</span>    max_depth = int(cubes_properties.size()) - 1;</div>
<div class="line"><span class="lineno"> 1487</span>        <span class="keyword">auto</span> process_triangle = [octree_ptr, max_depth, diag_half](<span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a> &amp;a, <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a> &amp;b, <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a> &amp;c) {</div>
<div class="line"><span class="lineno"> 1488</span>            octree_ptr-&gt;<a class="code hl_function" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#ab3805442b26a46fc8b97e66b902800ca">insert_triangle</a>(</div>
<div class="line"><span class="lineno"> 1489</span>                a, b, c,</div>
<div class="line"><span class="lineno"> 1490</span>                octree_ptr-&gt;<a class="code hl_variable" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#afaf27a6dff197a226f2113ca8d76ca2e">root_cube</a>,</div>
<div class="line"><span class="lineno"> 1491</span>                <a class="code hl_class" href="../../d6/d81/class_slic3r_1_1_bounding_boxf3.html">BoundingBoxf3</a>(octree_ptr-&gt;<a class="code hl_variable" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#afaf27a6dff197a226f2113ca8d76ca2e">root_cube</a>-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">center</a> - diag_half, octree_ptr-&gt;<a class="code hl_variable" href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#afaf27a6dff197a226f2113ca8d76ca2e">root_cube</a>-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">center</a> + diag_half),</div>
<div class="line"><span class="lineno"> 1492</span>                max_depth);</div>
<div class="line"><span class="lineno"> 1493</span>        };</div>
<div class="line"><span class="lineno"> 1494</span>        <span class="keyword">auto</span> up_vector = support_overhangs_only ? <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a>(transform_to_octree() * <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a>(0., 0., 1.)) : <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a>();</div>
<div class="line"><span class="lineno"> 1495</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;tri : triangle_mesh.indices) {</div>
<div class="line"><span class="lineno"> 1496</span>            <span class="keyword">auto</span> a = triangle_mesh.<a class="code hl_variable" href="../../d0/df2/structindexed__triangle__set.html#a86d0433f7db7abf0f94c7e3d1302b09c">vertices</a>[tri[0]].cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno"> 1497</span>            <span class="keyword">auto</span> b = triangle_mesh.<a class="code hl_variable" href="../../d0/df2/structindexed__triangle__set.html#a86d0433f7db7abf0f94c7e3d1302b09c">vertices</a>[tri[1]].cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno"> 1498</span>            <span class="keyword">auto</span> c = triangle_mesh.<a class="code hl_variable" href="../../d0/df2/structindexed__triangle__set.html#a86d0433f7db7abf0f94c7e3d1302b09c">vertices</a>[tri[2]].cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno"> 1499</span>            <span class="keywordflow">if</span> (! support_overhangs_only || is_overhang_triangle(a, b, c, up_vector))</div>
<div class="line"><span class="lineno"> 1500</span>                process_triangle(a, b, c);</div>
<div class="line"><span class="lineno"> 1501</span>        }</div>
<div class="line"><span class="lineno"> 1502</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; overhang_triangles.size(); i += 3)</div>
<div class="line"><span class="lineno"> 1503</span>            process_triangle(overhang_triangles[i], overhang_triangles[i + 1], overhang_triangles[i + 2]);</div>
<div class="line"><span class="lineno"> 1504</span>        {</div>
<div class="line"><span class="lineno"> 1505</span>            <span class="comment">// Transform the octree to world coordinates to reduce computation when extracting infill lines.</span></div>
<div class="line"><span class="lineno"> 1506</span>            <span class="keyword">auto</span> rot = transform_to_world().<a class="code hl_function" href="../../d5/d00/group___geometry___module.html#a621c71eec9680bf77342b28a473b6874">toRotationMatrix</a>();</div>
<div class="line"><span class="lineno"> 1507</span>            transform_center(octree-&gt;root_cube, rot);</div>
<div class="line"><span class="lineno"> 1508</span>            octree-&gt;origin = rot * octree-&gt;origin;</div>
<div class="line"><span class="lineno"> 1509</span>        }</div>
<div class="line"><span class="lineno"> 1510</span>    }</div>
<div class="line"><span class="lineno"> 1511</span> </div>
<div class="line"><span class="lineno"> 1512</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#a5806fc4474f7d227eb06c1d67b0b677b">octree</a>;</div>
<div class="line"><span class="lineno"> 1513</span>}</div>
<div class="ttc" id="aclass_slic3r_1_1_bounding_box3_base_html"><div class="ttname"><a href="../../da/d00/class_slic3r_1_1_bounding_box3_base.html">Slic3r::BoundingBox3Base</a></div><div class="ttdef"><b>Definition</b> BoundingBox.hpp:87</div></div>
<div class="ttc" id="aclass_slic3r_1_1_bounding_boxf3_html"><div class="ttname"><a href="../../d6/d81/class_slic3r_1_1_bounding_boxf3.html">Slic3r::BoundingBoxf3</a></div><div class="ttdef"><b>Definition</b> BoundingBox.hpp:221</div></div>
<div class="ttc" id="agroup___geometry___module_html_a621c71eec9680bf77342b28a473b6874"><div class="ttname"><a href="../../d5/d00/group___geometry___module.html#a621c71eec9680bf77342b28a473b6874">Eigen::QuaternionBase::toRotationMatrix</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC Matrix3 toRotationMatrix() const</div><div class="ttdef"><b>Definition</b> Quaternion.h:536</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a26cd64cc9ecd14940e8bd93de0b57326"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a26cd64cc9ecd14940e8bd93de0b57326">Slic3r::FillAdaptive::OctreePtr</a></div><div class="ttdeci">std::unique_ptr&lt; Octree, OctreeDeleter &gt; OctreePtr</div><div class="ttdef"><b>Definition</b> FillAdaptive.hpp:28</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_ab8b1d64bf2fbe2f31e06e70cfe6d33cf"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab8b1d64bf2fbe2f31e06e70cfe6d33cf">Slic3r::FillAdaptive::make_cubes_properties</a></div><div class="ttdeci">static std::vector&lt; CubeProperties &gt; make_cubes_properties(double max_cube_edge_length, double line_spacing)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:1427</div></div>
<div class="ttc" id="anamespaceigl_html_a5806fc4474f7d227eb06c1d67b0b677b"><div class="ttname"><a href="../../dc/d25/namespaceigl.html#a5806fc4474f7d227eb06c1d67b0b677b">igl::octree</a></div><div class="ttdeci">IGL_INLINE void octree(const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;point_indices, Eigen::PlainObjectBase&lt; DerivedCH &gt; &amp;CH, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</div><div class="ttdef"><b>Definition</b> octree.cpp:8</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_cube_html_a3699025a7d1dbec009345b4ba5f30ea2"><div class="ttname"><a href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">Slic3r::FillAdaptive::Cube::center</a></div><div class="ttdeci">Vec3d center</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:240</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_octree_html"><div class="ttname"><a href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html">Slic3r::FillAdaptive::Octree</a></div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:258</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_octree_html_ab3805442b26a46fc8b97e66b902800ca"><div class="ttname"><a href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#ab3805442b26a46fc8b97e66b902800ca">Slic3r::FillAdaptive::Octree::insert_triangle</a></div><div class="ttdeci">void insert_triangle(const Vec3d &amp;a, const Vec3d &amp;b, const Vec3d &amp;c, Cube *current_cube, const BoundingBoxf3 &amp;current_bbox, int depth)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:1515</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_octree_html_afaf27a6dff197a226f2113ca8d76ca2e"><div class="ttname"><a href="../../d4/dad/struct_slic3r_1_1_fill_adaptive_1_1_octree.html#afaf27a6dff197a226f2113ca8d76ca2e">Slic3r::FillAdaptive::Octree::root_cube</a></div><div class="ttdeci">Cube * root_cube</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:262</div></div>
<div class="ttc" id="astructindexed__triangle__set_html_a86d0433f7db7abf0f94c7e3d1302b09c"><div class="ttname"><a href="../../d0/df2/structindexed__triangle__set.html#a86d0433f7db7abf0f94c7e3d1302b09c">indexed_triangle_set::vertices</a></div><div class="ttdeci">std::vector&lt; stl_vertex &gt; vertices</div><div class="ttdef"><b>Definition</b> stl.h:165</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l01465">build_octree()</a>, <a class="el" href="../../#l00203">Slic3r::BoundingBox3Base&lt; PointType &gt;::center()</a>, <a class="el" href="../../#l00240">Slic3r::FillAdaptive::Cube::center</a>, <a class="el" href="../../#l00164">indexed_triangle_set::indices</a>, <a class="el" href="../../#l01515">Slic3r::FillAdaptive::Octree::insert_triangle()</a>, <a class="el" href="../../#l01447">is_overhang_triangle()</a>, <a class="el" href="../../#l01427">make_cubes_properties()</a>, <a class="el" href="../../#l00262">Slic3r::FillAdaptive::Octree::root_cube</a>, <a class="el" href="../../#l00153">Slic3r::BoundingBox3Base&lt; PointType &gt;::size()</a>, <a class="el" href="../../#l00536">Eigen::QuaternionBase&lt; Derived &gt;::toRotationMatrix()</a>, <a class="el" href="../../#l01454">transform_center()</a>, <a class="el" href="../../#l00407">transform_to_octree()</a>, <a class="el" href="../../#l00402">transform_to_world()</a>, and <a class="el" href="../../#l00165">indexed_triangle_set::vertices</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00276">adaptive_fill_line_spacing()</a>, and <a class="el" href="../../#l01465">build_octree()</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_aec5a53e88fc9e4f3c11af2874b10c3dd_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_aec5a53e88fc9e4f3c11af2874b10c3dd_icgraph.svg" width="320" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="afb2f3cac794562525dd4a5ea6cc44fec" name="afb2f3cac794562525dd4a5ea6cc44fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2f3cac794562525dd4a5ea6cc44fec">&#9670;&#160;</a></span>connect_lines_using_hooks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> Slic3r::FillAdaptive::connect_lines_using_hooks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../db/dc4/class_slic3r_1_1_ex_polygon.html">ExPolygon</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a>&#160;</td>
          <td class="paramname"><em>hook_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a2ac5c755948c74f5f5f975acd5057fe9">coordf_t</a>&#160;</td>
          <td class="paramname"><em>hook_length_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  801</span>{</div>
<div class="line"><span class="lineno">  802</span>    <a class="code hl_typedef" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">rtree_t</a> rtree;</div>
<div class="line"><span class="lineno">  803</span>    <span class="keywordtype">size_t</span>  poly_idx = 0;</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>    <span class="comment">// 19% overlap, slightly lower than the allowed overlap in Fill::connect_infill()</span></div>
<div class="line"><span class="lineno">  806</span>    <span class="keyword">const</span> <span class="keywordtype">float</span> scaled_offset           = float(<a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a5e7dd5d14b7e7bb8f1dab0fd4fa3e0f2">scale_</a>(spacing) * 0.81);</div>
<div class="line"><span class="lineno">  807</span>    <span class="comment">// 25% overlap</span></div>
<div class="line"><span class="lineno">  808</span>    <span class="keyword">const</span> <span class="keywordtype">float</span> scaled_trim_distance    = float(<a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a5e7dd5d14b7e7bb8f1dab0fd4fa3e0f2">scale_</a>(spacing) * 0.5 * 0.75);</div>
<div class="line"><span class="lineno">  809</span> </div>
<div class="line"><span class="lineno">  810</span>    <span class="comment">// Keeping the vector of closest points outside the loop, so the vector does not need to be reallocated.</span></div>
<div class="line"><span class="lineno">  811</span>    std::vector&lt;std::pair&lt;rtree_segment_t, size_t&gt;&gt; closest;</div>
<div class="line"><span class="lineno">  812</span>    <span class="comment">// Pairs of lines touching at one end point. The pair is sorted to make the end point connection test symmetric.</span></div>
<div class="line"><span class="lineno">  813</span>    std::vector&lt;std::pair&lt;const Polyline*, const Polyline*&gt;&gt; lines_touching_at_endpoints;</div>
<div class="line"><span class="lineno">  814</span>    {</div>
<div class="line"><span class="lineno">  815</span>        <span class="comment">// Insert infill lines into rtree, merge close collinear segments split by the infill boundary,</span></div>
<div class="line"><span class="lineno">  816</span>        <span class="comment">// collect lines_touching_at_endpoints.</span></div>
<div class="line"><span class="lineno">  817</span>        <span class="keywordtype">double</span> r2_close = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a9f09756940b3eb2052058460bf07e4a3">Slic3r::sqr</a>(1200.);</div>
<div class="line"><span class="lineno">  818</span>        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a> &amp;poly : lines) {</div>
<div class="line"><span class="lineno">  819</span>            assert(poly.points.size() == 2);</div>
<div class="line"><span class="lineno">  820</span>            <span class="keywordflow">if</span> (&amp;poly != lines.data()) {</div>
<div class="line"><span class="lineno">  821</span>                <span class="comment">// Join collinear segments separated by a tiny gap. These gaps were likely created by clipping the infill lines with a concave dent in an infill boundary.</span></div>
<div class="line"><span class="lineno">  822</span>                <span class="keyword">auto</span> collinear_segment = [&amp;rtree, &amp;closest, &amp;lines, &amp;lines_touching_at_endpoints, r2_close](<span class="keyword">const</span> <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a>&amp; pt, <span class="keyword">const</span> <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a>&amp; pt_other, <span class="keyword">const</span> <a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a>* polyline) -&gt; std::pair&lt;Polyline*, bool&gt; {</div>
<div class="line"><span class="lineno">  823</span>                    closest.clear();</div>
<div class="line"><span class="lineno">  824</span>                    rtree.query(bgi::nearest(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">mk_rtree_point</a>(pt), 1), std::back_inserter(closest));</div>
<div class="line"><span class="lineno">  825</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a> *other = &amp;lines[closest.front().second];</div>
<div class="line"><span class="lineno">  826</span>                    <span class="keywordtype">double</span> dist2_front = (other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.front() - pt).cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno">  827</span>                    <span class="keywordtype">double</span> dist2_back  = (other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back() - pt).cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno">  828</span>                    <span class="keywordtype">double</span> dist2_min   = std::min(dist2_front, dist2_back);</div>
<div class="line"><span class="lineno">  829</span>                    <span class="keywordflow">if</span> (dist2_min &lt; r2_close) {</div>
<div class="line"><span class="lineno">  830</span>                        <span class="comment">// Don&#39;t connect the segments in an opposite direction.</span></div>
<div class="line"><span class="lineno">  831</span>                        <span class="keywordtype">double</span> dist2_min_other = std::min((other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.front() - pt_other).cast&lt;<span class="keywordtype">double</span>&gt;().squaredNorm(), (other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back() - pt_other).cast&lt;<span class="keywordtype">double</span>&gt;().squaredNorm());</div>
<div class="line"><span class="lineno">  832</span>                        <span class="keywordflow">if</span> (dist2_min_other &gt; dist2_min) {</div>
<div class="line"><span class="lineno">  833</span>                            <span class="comment">// End points of the two lines are very close, they should have been merged together if they are collinear.</span></div>
<div class="line"><span class="lineno">  834</span>                            <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> v1 = (pt_other - pt).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  835</span>                            <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> v2 = (other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back() - other-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.front()).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  836</span>                            <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> v1n = v1.normalized();</div>
<div class="line"><span class="lineno">  837</span>                            <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> v2n = v2.normalized();</div>
<div class="line"><span class="lineno">  838</span>                            <span class="comment">// The vectors must not be collinear.</span></div>
<div class="line"><span class="lineno">  839</span>                            <span class="keywordtype">double</span> d = v1n.dot(v2n);</div>
<div class="line"><span class="lineno">  840</span>                            <span class="keywordflow">if</span> (std::abs(d) &gt; 0.99f) {</div>
<div class="line"><span class="lineno">  841</span>                                <span class="comment">// Lines are collinear, merge them.</span></div>
<div class="line"><span class="lineno">  842</span>                                rtree.remove(closest.front());</div>
<div class="line"><span class="lineno">  843</span>                                <span class="keywordflow">return</span> std::make_pair(<span class="keyword">const_cast&lt;</span><a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a>*<span class="keyword">&gt;</span>(other), dist2_min == dist2_front);</div>
<div class="line"><span class="lineno">  844</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  845</span>                                <span class="keywordflow">if</span> (polyline &gt; other)</div>
<div class="line"><span class="lineno">  846</span>                                    std::swap(polyline, other);</div>
<div class="line"><span class="lineno">  847</span>                                lines_touching_at_endpoints.emplace_back(polyline, other);</div>
<div class="line"><span class="lineno">  848</span>                            }</div>
<div class="line"><span class="lineno">  849</span>                        }</div>
<div class="line"><span class="lineno">  850</span>                    }</div>
<div class="line"><span class="lineno">  851</span>                    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">static_cast&lt;</span>Polyline*<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  852</span>                };</div>
<div class="line"><span class="lineno">  853</span>                <span class="keyword">auto</span> collinear_front = collinear_segment(poly.points.front(), poly.points.back(),  &amp;poly);</div>
<div class="line"><span class="lineno">  854</span>                <span class="keyword">auto</span> collinear_back  = collinear_segment(poly.points.back(),  poly.points.front(), &amp;poly);</div>
<div class="line"><span class="lineno">  855</span>                assert(! collinear_front.first || ! collinear_back.first || collinear_front.first != collinear_back.first);</div>
<div class="line"><span class="lineno">  856</span>                <span class="keywordflow">if</span> (collinear_front.first) {</div>
<div class="line"><span class="lineno">  857</span>                    Polyline &amp;other = *collinear_front.first;</div>
<div class="line"><span class="lineno">  858</span>                    assert(&amp;other != &amp;poly);</div>
<div class="line"><span class="lineno">  859</span>                    poly.points.front() = collinear_front.second ? other.points.back() : other.points.front();</div>
<div class="line"><span class="lineno">  860</span>                    other.points.clear();</div>
<div class="line"><span class="lineno">  861</span>                }</div>
<div class="line"><span class="lineno">  862</span>                <span class="keywordflow">if</span> (collinear_back.first) {</div>
<div class="line"><span class="lineno">  863</span>                    Polyline &amp;other = *collinear_back.first;</div>
<div class="line"><span class="lineno">  864</span>                    assert(&amp;other != &amp;poly);</div>
<div class="line"><span class="lineno">  865</span>                    poly.points.back() = collinear_back.second ? other.points.back() : other.points.front();</div>
<div class="line"><span class="lineno">  866</span>                    other.points.clear();</div>
<div class="line"><span class="lineno">  867</span>                }</div>
<div class="line"><span class="lineno">  868</span>            }</div>
<div class="line"><span class="lineno">  869</span>            rtree.insert(std::make_pair(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(poly.points.front(), poly.points.back()), poly_idx++));</div>
<div class="line"><span class="lineno">  870</span>        }</div>
<div class="line"><span class="lineno">  871</span>    }</div>
<div class="line"><span class="lineno">  872</span> </div>
<div class="line"><span class="lineno">  873</span>    <span class="comment">// Convert input polylines to lines_src after the colinear segments were merged.</span></div>
<div class="line"><span class="lineno">  874</span>    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a0913e2e6b7d28032c33cfee03f145fba">Lines</a> lines_src;</div>
<div class="line"><span class="lineno">  875</span>    lines_src.reserve(lines.size());</div>
<div class="line"><span class="lineno">  876</span>    std::transform(lines.begin(), lines.end(), std::back_inserter(lines_src), [](<span class="keyword">const</span> Polyline &amp;pl) { </div>
<div class="line"><span class="lineno">  877</span>        return pl.empty() ? Line(Point(0, 0), Point(0, 0)) : Line(pl.points.front(), pl.points.back()); });</div>
<div class="line"><span class="lineno">  878</span> </div>
<div class="line"><span class="lineno">  879</span>    <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#aa3af3ee03fdd2fbda072bbea6de1f8fc">sort_remove_duplicates</a>(lines_touching_at_endpoints);</div>
<div class="line"><span class="lineno">  880</span> </div>
<div class="line"><span class="lineno">  881</span>    std::vector&lt;Intersection&gt; intersections;</div>
<div class="line"><span class="lineno">  882</span>    {</div>
<div class="line"><span class="lineno">  883</span>        <span class="comment">// Minimum lenght of an infill line to anchor. Very short lines cannot be trimmed from both sides,</span></div>
<div class="line"><span class="lineno">  884</span>        <span class="comment">// it does not help to anchor extremely short infill lines, it consumes too much plastic while not adding</span></div>
<div class="line"><span class="lineno">  885</span>        <span class="comment">// to the object rigidity.</span></div>
<div class="line"><span class="lineno">  886</span>        assert(scaled_offset &gt; scaled_trim_distance);</div>
<div class="line"><span class="lineno">  887</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> line_len_threshold_drop_both_sides    = scaled_offset * (2. / <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a92b03396990b0e9eea0731aa406e31a4">cos</a>(<a class="code hl_variable" href="../../dd/d47/libslic3r_8h.html#a299aabc5fc8285cbf99025330a3d0d0d">PI</a> / 6.) + 0.5) + <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>;</div>
<div class="line"><span class="lineno">  888</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> line_len_threshold_anchor_both_sides  = line_len_threshold_drop_both_sides + scaled_offset;</div>
<div class="line"><span class="lineno">  889</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> line_len_threshold_drop_single_side   = scaled_offset * (1. / <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a92b03396990b0e9eea0731aa406e31a4">cos</a>(<a class="code hl_variable" href="../../dd/d47/libslic3r_8h.html#a299aabc5fc8285cbf99025330a3d0d0d">PI</a> / 6.) + 1.5) + <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>;</div>
<div class="line"><span class="lineno">  890</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> line_len_threshold_anchor_single_side = line_len_threshold_drop_single_side + scaled_offset;</div>
<div class="line"><span class="lineno">  891</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> line_idx = 0; line_idx &lt; lines.size(); ++ line_idx) {</div>
<div class="line"><span class="lineno">  892</span>            Polyline    &amp;line        = lines[line_idx];</div>
<div class="line"><span class="lineno">  893</span>            <span class="keywordflow">if</span> (line.points.empty())</div>
<div class="line"><span class="lineno">  894</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>            <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;front_point = line.points.front();</div>
<div class="line"><span class="lineno">  897</span>            <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;back_point  = line.points.back();</div>
<div class="line"><span class="lineno">  898</span> </div>
<div class="line"><span class="lineno">  899</span>            <span class="comment">// Find the nearest line from the start point of the line.</span></div>
<div class="line"><span class="lineno">  900</span>            std::optional&lt;size_t&gt; tjoint_front, tjoint_back;</div>
<div class="line"><span class="lineno">  901</span>            {</div>
<div class="line"><span class="lineno">  902</span>                <span class="keyword">auto</span> has_tjoint = [&amp;closest, line_idx, &amp;rtree, &amp;lines, &amp;lines_src](<span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;pt) {</div>
<div class="line"><span class="lineno">  903</span>                    <span class="keyword">auto</span> filter_t_joint = [line_idx, &amp;lines_src, pt](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item) { </div>
<div class="line"><span class="lineno">  904</span>                        <span class="keywordflow">if</span> (item.second != line_idx) {</div>
<div class="line"><span class="lineno">  905</span>                            <span class="comment">// Verify that the point projects onto the line.</span></div>
<div class="line"><span class="lineno">  906</span>                            <span class="keyword">const</span> Line  &amp;line = lines_src[item.second];</div>
<div class="line"><span class="lineno">  907</span>                            <span class="keyword">const</span> <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>  v  = (line.b - line.a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  908</span>                            <span class="keyword">const</span> <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>  va = (pt - line.a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  909</span>                            <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a> = v.squaredNorm();  <span class="comment">// avoid a sqrt</span></div>
<div class="line"><span class="lineno">  910</span>                            <span class="keywordflow">if</span> (l2 &gt; 0.) {</div>
<div class="line"><span class="lineno">  911</span>                                <span class="keyword">const</span> <span class="keywordtype">double</span> t = va.dot(v);</div>
<div class="line"><span class="lineno">  912</span>                                <span class="keywordflow">return</span> t &gt; <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a> &amp;&amp; t &lt; <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a> - <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>;</div>
<div class="line"><span class="lineno">  913</span>                            }</div>
<div class="line"><span class="lineno">  914</span>                        }</div>
<div class="line"><span class="lineno">  915</span>                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  916</span>                    };</div>
<div class="line"><span class="lineno">  917</span>                    closest.clear();</div>
<div class="line"><span class="lineno">  918</span>                    rtree.query(bgi::nearest(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">mk_rtree_point</a>(pt), 1) &amp;&amp; bgi::satisfies(filter_t_joint), std::back_inserter(closest));</div>
<div class="line"><span class="lineno">  919</span>                    std::optional&lt;size_t&gt; out;</div>
<div class="line"><span class="lineno">  920</span>                    <span class="keywordflow">if</span> (! closest.empty()) {</div>
<div class="line"><span class="lineno">  921</span>                        <span class="keyword">const</span> Polyline &amp;pl = lines[closest.front().second];</div>
<div class="line"><span class="lineno">  922</span>                        <span class="keywordflow">if</span> (pl.points.empty()) {</div>
<div class="line"><span class="lineno">  923</span>                            <span class="comment">// The closest infill line was already dropped as it was too short.</span></div>
<div class="line"><span class="lineno">  924</span>                            <span class="comment">// Such an infill line should not make a T-joint anyways.</span></div>
<div class="line"><span class="lineno">  925</span><span class="preprocessor">    #if 0 </span><span class="comment">// #ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  926</span>                            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;seg = closest.front().first;</div>
<div class="line"><span class="lineno">  927</span>                            <span class="keyword">struct </span>Linef { <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> <a class="code hl_enumvalue" href="../../d9/d6c/namespacemarchsq_1_1____impl.html#a5c3960032271d7907677d3507c909780a0cc175b9c0f1b6a831c399e269772661">a</a>; <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> <a class="code hl_enumvalue" href="../../d9/d6c/namespacemarchsq_1_1____impl.html#a5c3960032271d7907677d3507c909780a92eb5ffee6ae2fec3ad71c777531578f">b</a>; };</div>
<div class="line"><span class="lineno">  928</span>                            Linef l { { bg::get&lt;0, 0&gt;(seg), bg::get&lt;0, 1&gt;(seg) }, { bg::get&lt;1, 0&gt;(seg), bg::get&lt;1, 1&gt;(seg) } };</div>
<div class="line"><span class="lineno">  929</span>                            assert(line_alg::distance_to_squared(l, <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>(pt.cast&lt;<span class="keywordtype">double</span>&gt;())) &gt; 1000 * 1000);</div>
<div class="line"><span class="lineno">  930</span><span class="preprocessor">    #endif </span><span class="comment">// NDEBUG</span></div>
<div class="line"><span class="lineno">  931</span>                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pl.size() &gt;= 2 &amp;&amp; </div>
<div class="line"><span class="lineno">  932</span>                            <span class="comment">//FIXME Hoping that pl is really a line, trimmed by a polygon using ClipperUtils. Sometimes Clipper leaves some additional collinear points on the polyline, let&#39;s hope it is all right.</span></div>
<div class="line"><span class="lineno">  933</span>                            Line{ pl.front(), pl.back() }.distance_to_squared(pt) &lt;= 1000 * 1000)</div>
<div class="line"><span class="lineno">  934</span>                            out = closest.front().second;</div>
<div class="line"><span class="lineno">  935</span>                    }</div>
<div class="line"><span class="lineno">  936</span>                    <span class="keywordflow">return</span> out;</div>
<div class="line"><span class="lineno">  937</span>                };</div>
<div class="line"><span class="lineno">  938</span>                <span class="comment">// Refuse to create a T-joint if the infill lines touch at their ends.</span></div>
<div class="line"><span class="lineno">  939</span>                <span class="keyword">auto</span> filter_end_point_connections = [&amp;lines_touching_at_endpoints, &amp;lines, &amp;line](std::optional&lt;size_t&gt; in) {</div>
<div class="line"><span class="lineno">  940</span>                    std::optional&lt;size_t&gt; out;</div>
<div class="line"><span class="lineno">  941</span>                    <span class="keywordflow">if</span> (in) {</div>
<div class="line"><span class="lineno">  942</span>                        <span class="keyword">const</span> Polyline *lo = &amp;line;</div>
<div class="line"><span class="lineno">  943</span>                        <span class="keyword">const</span> Polyline *hi = &amp;lines[*in];</div>
<div class="line"><span class="lineno">  944</span>                        <span class="keywordflow">if</span> (lo &gt; hi)</div>
<div class="line"><span class="lineno">  945</span>                            std::swap(lo, hi);</div>
<div class="line"><span class="lineno">  946</span>                        <span class="keywordflow">if</span> (! std::binary_search(lines_touching_at_endpoints.begin(), lines_touching_at_endpoints.end(), std::make_pair(lo, hi)))</div>
<div class="line"><span class="lineno">  947</span>                            <span class="comment">// Not an end-point connection, it is a valid T-joint.</span></div>
<div class="line"><span class="lineno">  948</span>                            out = in;</div>
<div class="line"><span class="lineno">  949</span>                    }</div>
<div class="line"><span class="lineno">  950</span>                    <span class="keywordflow">return</span> out;</div>
<div class="line"><span class="lineno">  951</span>                };</div>
<div class="line"><span class="lineno">  952</span>                tjoint_front = filter_end_point_connections(has_tjoint(front_point));</div>
<div class="line"><span class="lineno">  953</span>                tjoint_back  = filter_end_point_connections(has_tjoint(back_point));</div>
<div class="line"><span class="lineno">  954</span>            }</div>
<div class="line"><span class="lineno">  955</span> </div>
<div class="line"><span class="lineno">  956</span>            <span class="keywordtype">int</span> num_tjoints = int(tjoint_front.has_value()) + int(tjoint_back.has_value());</div>
<div class="line"><span class="lineno">  957</span>            <span class="keywordflow">if</span> (num_tjoints &gt; 0) {</div>
<div class="line"><span class="lineno">  958</span>                <span class="keywordtype">double</span> line_len   = line.length();</div>
<div class="line"><span class="lineno">  959</span>                <span class="keywordtype">bool</span>   drop       = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  960</span>                <span class="keywordtype">bool</span>   anchor     = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  961</span>                <span class="keywordflow">if</span> (num_tjoints == 1) {</div>
<div class="line"><span class="lineno">  962</span>                    <span class="comment">// Connected to perimeters on a single side only, connected to another infill line on the other side.</span></div>
<div class="line"><span class="lineno">  963</span>                    drop   = line_len &lt; line_len_threshold_drop_single_side;</div>
<div class="line"><span class="lineno">  964</span>                    anchor = line_len &gt; line_len_threshold_anchor_single_side;</div>
<div class="line"><span class="lineno">  965</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  966</span>                    <span class="comment">// Not connected to perimeters at all, connected to two infill lines.</span></div>
<div class="line"><span class="lineno">  967</span>                    assert(num_tjoints == 2);                    </div>
<div class="line"><span class="lineno">  968</span>                    drop   = line_len &lt; line_len_threshold_drop_both_sides;</div>
<div class="line"><span class="lineno">  969</span>                    anchor = line_len &gt; line_len_threshold_anchor_both_sides;</div>
<div class="line"><span class="lineno">  970</span>                }</div>
<div class="line"><span class="lineno">  971</span>                <span class="keywordflow">if</span> (drop) {</div>
<div class="line"><span class="lineno">  972</span>                    <span class="comment">// Drop a very short line if connected to another infill line.</span></div>
<div class="line"><span class="lineno">  973</span>                    <span class="comment">// Lines shorter than spacing are skipped because it is needed to shrink a line by the value of spacing.</span></div>
<div class="line"><span class="lineno">  974</span>                    <span class="comment">// A shorter line than spacing could produce a degenerate polyline.</span></div>
<div class="line"><span class="lineno">  975</span>                    line.points.clear();</div>
<div class="line"><span class="lineno">  976</span>                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (anchor) {</div>
<div class="line"><span class="lineno">  977</span>                    <span class="keywordflow">if</span> (tjoint_front) {</div>
<div class="line"><span class="lineno">  978</span>                        <span class="comment">// T-joint of line&#39;s front point with the &#39;closest&#39; line.</span></div>
<div class="line"><span class="lineno">  979</span>                        intersections.emplace_back(lines_src[*tjoint_front], lines_src[line_idx], &amp;line, front_point, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  980</span>                        assert(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a62b6c3850ee31bb8711301708ef104a9">validate_intersection_t_joint</a>(intersections.back()));</div>
<div class="line"><span class="lineno">  981</span>                    }</div>
<div class="line"><span class="lineno">  982</span>                    <span class="keywordflow">if</span> (tjoint_back) {</div>
<div class="line"><span class="lineno">  983</span>                        <span class="comment">// T-joint of line&#39;s back point with the &#39;closest&#39; line.</span></div>
<div class="line"><span class="lineno">  984</span>                        intersections.emplace_back(lines_src[*tjoint_back],  lines_src[line_idx], &amp;line, back_point,  <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  985</span>                        assert(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a62b6c3850ee31bb8711301708ef104a9">validate_intersection_t_joint</a>(intersections.back()));</div>
<div class="line"><span class="lineno">  986</span>                    }</div>
<div class="line"><span class="lineno">  987</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  988</span>                    <span class="keywordflow">if</span> (tjoint_front)</div>
<div class="line"><span class="lineno">  989</span>                        <span class="comment">// T joint at the front at a 60 degree angle, the line is very short.</span></div>
<div class="line"><span class="lineno">  990</span>                        <span class="comment">// Trim the front side.</span></div>
<div class="line"><span class="lineno">  991</span>                        front_point += ((scaled_trim_distance * 1.155) * (back_point - front_point).cast&lt;<span class="keywordtype">double</span>&gt;().normalized()).cast&lt;coord_t&gt;();</div>
<div class="line"><span class="lineno">  992</span>                    <span class="keywordflow">if</span> (tjoint_back)</div>
<div class="line"><span class="lineno">  993</span>                        <span class="comment">// T joint at the front at a 60 degree angle, the line is very short.</span></div>
<div class="line"><span class="lineno">  994</span>                        <span class="comment">// Trim the front side.</span></div>
<div class="line"><span class="lineno">  995</span>                        back_point  += ((scaled_trim_distance * 1.155) * (front_point - back_point).cast&lt;<span class="keywordtype">double</span>&gt;().normalized()).cast&lt;coord_t&gt;();</div>
<div class="line"><span class="lineno">  996</span>                }</div>
<div class="line"><span class="lineno">  997</span>            }</div>
<div class="line"><span class="lineno">  998</span>        }</div>
<div class="line"><span class="lineno">  999</span>        <span class="comment">// Remove those intersections, that point to a dropped line.</span></div>
<div class="line"><span class="lineno"> 1000</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = intersections.begin(); it != intersections.end(); ) {</div>
<div class="line"><span class="lineno"> 1001</span>            assert(! lines[it-&gt;intersect_line - lines_src.data()].points.empty());</div>
<div class="line"><span class="lineno"> 1002</span>            <span class="keywordflow">if</span> (lines[it-&gt;closest_line - lines_src.data()].points.empty()) {</div>
<div class="line"><span class="lineno"> 1003</span>                *it = intersections.back();</div>
<div class="line"><span class="lineno"> 1004</span>                intersections.pop_back();</div>
<div class="line"><span class="lineno"> 1005</span>            } <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1006</span>                ++ it;</div>
<div class="line"><span class="lineno"> 1007</span>        }</div>
<div class="line"><span class="lineno"> 1008</span>    }</div>
<div class="line"><span class="lineno"> 1009</span>    assert(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3e8df2806894ebc7012c77ec366d8525">validate_intersections</a>(intersections));</div>
<div class="line"><span class="lineno"> 1010</span> </div>
<div class="line"><span class="lineno"> 1011</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1012</span>    <span class="keyword">static</span> <span class="keywordtype">int</span> iRun = 0;</div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordtype">int</span> iStep = 0;</div>
<div class="line"><span class="lineno"> 1014</span>    {</div>
<div class="line"><span class="lineno"> 1015</span>        <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#aee987cbd1647986a9ac92226daffa4d7">Points</a> pts;</div>
<div class="line"><span class="lineno"> 1016</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Intersection &amp;i : intersections)</div>
<div class="line"><span class="lineno"> 1017</span>            pts.emplace_back(i.intersect_point);</div>
<div class="line"><span class="lineno"> 1018</span>        export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-Tjoints-%d.svg&quot;</span>, iRun++), pts);</div>
<div class="line"><span class="lineno"> 1019</span>    }</div>
<div class="line"><span class="lineno"> 1020</span><span class="preprocessor">#endif </span><span class="comment">/* ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT */</span><span class="preprocessor"></span></div>
<div class="line"><span class="lineno"> 1021</span> </div>
<div class="line"><span class="lineno"> 1022</span>    <span class="comment">// Sort lexicographically by closest_line_idx and left/right orientation.</span></div>
<div class="line"><span class="lineno"> 1023</span>    std::sort(intersections.begin(), intersections.end(),</div>
<div class="line"><span class="lineno"> 1024</span>      [](<span class="keyword">const</span> Intersection &amp;i1, <span class="keyword">const</span> Intersection &amp;i2) {</div>
<div class="line"><span class="lineno"> 1025</span>            return (i1.closest_line == i2.closest_line) ?</div>
<div class="line"><span class="lineno"> 1026</span>                int(i1.left) &lt; int(i2.left) :</div>
<div class="line"><span class="lineno"> 1027</span>                i1.closest_line &lt; i2.closest_line;</div>
<div class="line"><span class="lineno"> 1028</span>        });</div>
<div class="line"><span class="lineno"> 1029</span> </div>
<div class="line"><span class="lineno"> 1030</span>    std::vector&lt;size_t&gt; merged_with(lines.size());</div>
<div class="line"><span class="lineno"> 1031</span>    std::iota(merged_with.begin(), merged_with.end(), 0);</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>    <span class="comment">// Appends the boundary polygon with all holes to rtree for detection to check whether hooks are not crossing the boundary</span></div>
<div class="line"><span class="lineno"> 1034</span>    {</div>
<div class="line"><span class="lineno"> 1035</span>        <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> prev = boundary.<a class="code hl_variable" href="../../db/dc4/class_slic3r_1_1_ex_polygon.html#a3fd4f1e86f356c9ac79dabfda8b43aec">contour</a>.<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back();</div>
<div class="line"><span class="lineno"> 1036</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;point : boundary.<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a1e3d7fa98691c1716fe860ec229e2ff7">contour</a>.points) {</div>
<div class="line"><span class="lineno"> 1037</span>            rtree.insert(std::make_pair(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(prev, point), poly_idx++));</div>
<div class="line"><span class="lineno"> 1038</span>            prev = point;</div>
<div class="line"><span class="lineno"> 1039</span>        }</div>
<div class="line"><span class="lineno"> 1040</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> Polygon &amp;polygon : boundary.<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae1af6ac7a0feb7823506bcb23660a137">holes</a>) {</div>
<div class="line"><span class="lineno"> 1041</span>            <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> prev = polygon.points.back();</div>
<div class="line"><span class="lineno"> 1042</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> &amp;point : polygon.points) {</div>
<div class="line"><span class="lineno"> 1043</span>                rtree.insert(std::make_pair(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(prev, point), poly_idx++));</div>
<div class="line"><span class="lineno"> 1044</span>                prev = point;</div>
<div class="line"><span class="lineno"> 1045</span>            }</div>
<div class="line"><span class="lineno"> 1046</span>        }</div>
<div class="line"><span class="lineno"> 1047</span>    }</div>
<div class="line"><span class="lineno"> 1048</span> </div>
<div class="line"><span class="lineno"> 1049</span>    <span class="keyword">auto</span> update_merged_polyline_idx = [&amp;merged_with](<span class="keywordtype">size_t</span> pl_idx) {</div>
<div class="line"><span class="lineno"> 1050</span>        <span class="comment">// Update the polyline index to index which is merged</span></div>
<div class="line"><span class="lineno"> 1051</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> last = pl_idx;;) {</div>
<div class="line"><span class="lineno"> 1052</span>            <span class="keywordtype">size_t</span> lower = merged_with[last];</div>
<div class="line"><span class="lineno"> 1053</span>            <span class="keywordflow">if</span> (lower == last) {</div>
<div class="line"><span class="lineno"> 1054</span>                merged_with[pl_idx] = lower;</div>
<div class="line"><span class="lineno"> 1055</span>                <span class="keywordflow">return</span> lower;</div>
<div class="line"><span class="lineno"> 1056</span>            }</div>
<div class="line"><span class="lineno"> 1057</span>            last = lower;</div>
<div class="line"><span class="lineno"> 1058</span>        }</div>
<div class="line"><span class="lineno"> 1059</span>        assert(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1060</span>        <span class="keywordflow">return</span> size_t(0);</div>
<div class="line"><span class="lineno"> 1061</span>    };</div>
<div class="line"><span class="lineno"> 1062</span>    <span class="keyword">auto</span> update_merged_polyline = [&amp;lines, update_merged_polyline_idx](<a class="code hl_enumvalue" href="../../d8/d2c/namespace_slic3r_1_1csg.html#a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24">Intersection</a>&amp; <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>) {</div>
<div class="line"><span class="lineno"> 1063</span>        <span class="comment">// Update the polyline index to index which is merged</span></div>
<div class="line"><span class="lineno"> 1064</span>        <span class="keywordtype">size_t</span> intersect_pl_idx = update_merged_polyline_idx(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl - lines.data());</div>
<div class="line"><span class="lineno"> 1065</span>        <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl = &amp;lines[intersect_pl_idx];</div>
<div class="line"><span class="lineno"> 1066</span>        <span class="comment">// After polylines are merged, it is necessary to update &quot;forward&quot; based on if intersect_point is the first or the last point of intersect_pl.</span></div>
<div class="line"><span class="lineno"> 1067</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.fresh()) {</div>
<div class="line"><span class="lineno"> 1068</span>            assert(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl-&gt;points.front() == <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_point ||</div>
<div class="line"><span class="lineno"> 1069</span>                   <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl-&gt;points.back() == <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_point);</div>
<div class="line"><span class="lineno"> 1070</span>            <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.front = <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_pl-&gt;points.front() == <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_point;</div>
<div class="line"><span class="lineno"> 1071</span>        }</div>
<div class="line"><span class="lineno"> 1072</span>    };</div>
<div class="line"><span class="lineno"> 1073</span> </div>
<div class="line"><span class="lineno"> 1074</span>    <span class="comment">// Merge polylines touching at their ends. This should be a very rare case, but it happens surprisingly often.</span></div>
<div class="line"><span class="lineno"> 1075</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = lines_touching_at_endpoints.rbegin(); it != lines_touching_at_endpoints.rend(); ++ it) {</div>
<div class="line"><span class="lineno"> 1076</span>        Polyline *pl1 = <span class="keyword">const_cast&lt;</span>Polyline*<span class="keyword">&gt;</span>(it-&gt;first);</div>
<div class="line"><span class="lineno"> 1077</span>        Polyline *pl2 = <span class="keyword">const_cast&lt;</span>Polyline*<span class="keyword">&gt;</span>(it-&gt;second);</div>
<div class="line"><span class="lineno"> 1078</span>        assert(pl1 &lt; pl2);</div>
<div class="line"><span class="lineno"> 1079</span>        <span class="comment">// pl1 was visited for the 1st time.</span></div>
<div class="line"><span class="lineno"> 1080</span>        <span class="comment">// pl2 may have alread been merged with another polyline, even with this one.</span></div>
<div class="line"><span class="lineno"> 1081</span>        pl2 = &amp;lines[update_merged_polyline_idx(pl2 - lines.data())];</div>
<div class="line"><span class="lineno"> 1082</span>        assert(pl1 &lt;= pl2);</div>
<div class="line"><span class="lineno"> 1083</span>        <span class="comment">// Avoid closing a loop, ignore dropped infill lines.</span></div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">if</span> (pl1 != pl2 &amp;&amp; ! pl1-&gt;points.empty() &amp;&amp; ! pl2-&gt;points.empty()) {</div>
<div class="line"><span class="lineno"> 1085</span>            <span class="comment">// Merge the polylines.</span></div>
<div class="line"><span class="lineno"> 1086</span>            assert(pl1 &lt; pl2);</div>
<div class="line"><span class="lineno"> 1087</span>            assert(pl1-&gt;points.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 1088</span>            assert(pl2-&gt;points.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 1089</span>            <span class="keywordtype">double</span> d11 = (pl1-&gt;points.front() - pl2-&gt;points.front()).cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno"> 1090</span>            <span class="keywordtype">double</span> d12 = (pl1-&gt;points.front() - pl2-&gt;points.back()) .cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno"> 1091</span>            <span class="keywordtype">double</span> d21 = (pl1-&gt;points.back()  - pl2-&gt;points.front()).cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno"> 1092</span>            <span class="keywordtype">double</span> d22 = (pl1-&gt;points.back()  - pl2-&gt;points.back()) .cast&lt;double&gt;().squaredNorm();</div>
<div class="line"><span class="lineno"> 1093</span>            <span class="keywordtype">double</span> d1min = std::min(d11, d12);</div>
<div class="line"><span class="lineno"> 1094</span>            <span class="keywordtype">double</span> d2min = std::min(d21, d22);</div>
<div class="line"><span class="lineno"> 1095</span>            <span class="keywordflow">if</span> (d1min &lt; d2min) {</div>
<div class="line"><span class="lineno"> 1096</span>                pl1-&gt;reverse();</div>
<div class="line"><span class="lineno"> 1097</span>                <span class="keywordflow">if</span> (d12 == d1min)</div>
<div class="line"><span class="lineno"> 1098</span>                    pl2-&gt;reverse();</div>
<div class="line"><span class="lineno"> 1099</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (d22 == d2min)</div>
<div class="line"><span class="lineno"> 1100</span>                pl2-&gt;reverse();</div>
<div class="line"><span class="lineno"> 1101</span>            pl1-&gt;points.back() = (pl1-&gt;points.back() + pl2-&gt;points.front()) / 2;</div>
<div class="line"><span class="lineno"> 1102</span>            pl1-&gt;append(pl2-&gt;points.begin() + 1, pl2-&gt;points.end());</div>
<div class="line"><span class="lineno"> 1103</span>            pl2-&gt;points.clear();</div>
<div class="line"><span class="lineno"> 1104</span>            merged_with[pl2 - lines.data()] = pl1 - lines.data();</div>
<div class="line"><span class="lineno"> 1105</span>        }</div>
<div class="line"><span class="lineno"> 1106</span>    }</div>
<div class="line"><span class="lineno"> 1107</span> </div>
<div class="line"><span class="lineno"> 1108</span>    <span class="comment">// Keep intersect_line outside the loop, so it does not get reallocated.</span></div>
<div class="line"><span class="lineno"> 1109</span>    std::vector&lt;std::pair&lt;Intersection*, double&gt;&gt; intersect_line;</div>
<div class="line"><span class="lineno"> 1110</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> min_idx = 0; min_idx &lt; intersections.size();) {</div>
<div class="line"><span class="lineno"> 1111</span>        intersect_line.clear();</div>
<div class="line"><span class="lineno"> 1112</span>        <span class="comment">// All the nearest points (T-joints) ending at the same line are projected onto this line. Because of it, it can easily find the nearest point.</span></div>
<div class="line"><span class="lineno"> 1113</span>        {</div>
<div class="line"><span class="lineno"> 1114</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> line_dir = intersections[min_idx].closest_line-&gt;vector().cast&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line"><span class="lineno"> 1115</span>            <span class="keywordtype">size_t</span> max_idx = min_idx;</div>
<div class="line"><span class="lineno"> 1116</span>            <span class="keywordflow">for</span> (; max_idx &lt; intersections.size() &amp;&amp; </div>
<div class="line"><span class="lineno"> 1117</span>                    intersections[min_idx].closest_line == intersections[max_idx].closest_line &amp;&amp;</div>
<div class="line"><span class="lineno"> 1118</span>                    intersections[min_idx].left         == intersections[max_idx].left;</div>
<div class="line"><span class="lineno"> 1119</span>                    ++ max_idx)</div>
<div class="line"><span class="lineno"> 1120</span>                intersect_line.emplace_back(&amp;intersections[max_idx], line_dir.dot(intersections[max_idx].intersect_point.cast&lt;<span class="keywordtype">double</span>&gt;()));</div>
<div class="line"><span class="lineno"> 1121</span>            min_idx = max_idx;</div>
<div class="line"><span class="lineno"> 1122</span>            assert(intersect_line.size() &gt; 0);</div>
<div class="line"><span class="lineno"> 1123</span>            <span class="comment">// Sort the intersections along line_dir.</span></div>
<div class="line"><span class="lineno"> 1124</span>            std::sort(intersect_line.begin(), intersect_line.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i1, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;i2) { return i1.second &lt; i2.second; });</div>
<div class="line"><span class="lineno"> 1125</span>        }</div>
<div class="line"><span class="lineno"> 1126</span> </div>
<div class="line"><span class="lineno"> 1127</span>        <span class="keywordflow">if</span> (intersect_line.size() == 1) {</div>
<div class="line"><span class="lineno"> 1128</span>            <span class="comment">// Simple case: The current intersection is the only one touching its adjacent line.</span></div>
<div class="line"><span class="lineno"> 1129</span>            <a class="code hl_enumvalue" href="../../d8/d2c/namespace_slic3r_1_1csg.html#a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24">Intersection</a> &amp;first_i = *intersect_line.front().first;</div>
<div class="line"><span class="lineno"> 1130</span>            update_merged_polyline(first_i);</div>
<div class="line"><span class="lineno"> 1131</span>            <span class="keywordflow">if</span> (first_i.fresh()) {</div>
<div class="line"><span class="lineno"> 1132</span>                <span class="comment">// Try to connect left or right. If not enough space for hook_length, take the longer side.</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1134</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-add_hook0-pre-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1135</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1136</span>                <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a8408e585ff5b07078360b31fd37a95e1">add_hook</a>(first_i, scaled_offset, hook_length, scaled_trim_distance, rtree, lines_src);</div>
<div class="line"><span class="lineno"> 1137</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1138</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-add_hook0-pre-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1139</span>                ++ iStep;</div>
<div class="line"><span class="lineno"> 1140</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1141</span>                first_i.used = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1142</span>            }</div>
<div class="line"><span class="lineno"> 1143</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1144</span>        }</div>
<div class="line"><span class="lineno"> 1145</span> </div>
<div class="line"><span class="lineno"> 1146</span>        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> first_idx = 0; first_idx &lt; intersect_line.size(); ++ first_idx) {</div>
<div class="line"><span class="lineno"> 1147</span>            <a class="code hl_enumvalue" href="../../d8/d2c/namespace_slic3r_1_1csg.html#a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24">Intersection</a> &amp;first_i = *intersect_line[first_idx].first;</div>
<div class="line"><span class="lineno"> 1148</span>            update_merged_polyline(first_i);</div>
<div class="line"><span class="lineno"> 1149</span>            <span class="keywordflow">if</span> (! first_i.fresh())</div>
<div class="line"><span class="lineno"> 1150</span>                <span class="comment">// The intersection has been processed, or the polyline has been merged to another polyline.</span></div>
<div class="line"><span class="lineno"> 1151</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span>            <span class="comment">// Get the previous or next intersection on the same line, pick the closer one.</span></div>
<div class="line"><span class="lineno"> 1154</span>            <span class="keywordflow">if</span> (first_idx &gt; 0)</div>
<div class="line"><span class="lineno"> 1155</span>                update_merged_polyline(*intersect_line[first_idx - 1].first);</div>
<div class="line"><span class="lineno"> 1156</span>            <span class="keywordflow">if</span> (first_idx + 1 &lt; intersect_line.size())</div>
<div class="line"><span class="lineno"> 1157</span>                update_merged_polyline(*intersect_line[first_idx + 1].first);</div>
<div class="line"><span class="lineno"> 1158</span>            <a class="code hl_enumvalue" href="../../d8/d2c/namespace_slic3r_1_1csg.html#a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24">Intersection</a> &amp;nearest_i = *<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab790231e61a09b487d6d06f4ed7360e3">get_nearest_intersection</a>(intersect_line, first_idx);</div>
<div class="line"><span class="lineno"> 1159</span>            assert(first_i.closest_line == nearest_i.closest_line);</div>
<div class="line"><span class="lineno"> 1160</span>            assert(first_i.intersect_line != nearest_i.intersect_line);</div>
<div class="line"><span class="lineno"> 1161</span>            assert(first_i.intersect_line != first_i.closest_line);</div>
<div class="line"><span class="lineno"> 1162</span>            assert(nearest_i.intersect_line != first_i.closest_line);</div>
<div class="line"><span class="lineno"> 1163</span>            <span class="comment">// A line between two intersections points</span></div>
<div class="line"><span class="lineno"> 1164</span>            Line offset_line = <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7f035675898b5ecaf6f84d2f73260b94">create_offset_line</a>(Line(first_i.intersect_point, nearest_i.intersect_point), first_i, scaled_offset);</div>
<div class="line"><span class="lineno"> 1165</span>            <span class="comment">// Check if both intersections lie on the offset_line and simultaneously get their points of intersecting.</span></div>
<div class="line"><span class="lineno"> 1166</span>            <span class="comment">// These points are used as start and end of the hook</span></div>
<div class="line"><span class="lineno"> 1167</span>            <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> first_i_point, nearest_i_point;</div>
<div class="line"><span class="lineno"> 1168</span>            <span class="keywordtype">bool</span> could_connect = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1169</span>            <span class="keywordflow">if</span> (nearest_i.fresh()) {</div>
<div class="line"><span class="lineno"> 1170</span>                could_connect = first_i.intersect_line-&gt;intersection(offset_line, &amp;first_i_point) &amp;&amp;</div>
<div class="line"><span class="lineno"> 1171</span>                                nearest_i.intersect_line-&gt;intersection(offset_line, &amp;nearest_i_point);</div>
<div class="line"><span class="lineno"> 1172</span>                assert(could_connect);</div>
<div class="line"><span class="lineno"> 1173</span>            }</div>
<div class="line"><span class="lineno"> 1174</span>            <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#aee987cbd1647986a9ac92226daffa4d7">Points</a> &amp;first_points  = first_i.intersect_pl-&gt;points;</div>
<div class="line"><span class="lineno"> 1175</span>            <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#aee987cbd1647986a9ac92226daffa4d7">Points</a> &amp;second_points = nearest_i.intersect_pl-&gt;points;</div>
<div class="line"><span class="lineno"> 1176</span>            could_connect &amp;= (nearest_i_point - first_i_point).cast&lt;double&gt;().squaredNorm() &lt;= <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a9f09756940b3eb2052058460bf07e4a3">Slic3r::sqr</a>(hook_length_max);</div>
<div class="line"><span class="lineno"> 1177</span>            <span class="keywordflow">if</span> (could_connect) {</div>
<div class="line"><span class="lineno"> 1178</span>                <span class="comment">// Both intersections are so close that their polylines can be connected.</span></div>
<div class="line"><span class="lineno"> 1179</span>                <span class="comment">// Verify that no other infill line intersects this anchor line.</span></div>
<div class="line"><span class="lineno"> 1180</span>                closest.clear();</div>
<div class="line"><span class="lineno"> 1181</span>                rtree.query(</div>
<div class="line"><span class="lineno"> 1182</span>                    bgi::intersects(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(first_i_point, nearest_i_point)) &amp;&amp;</div>
<div class="line"><span class="lineno"> 1183</span>                    bgi::satisfies([&amp;first_i, &amp;nearest_i, &amp;lines_src](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item) </div>
<div class="line"><span class="lineno"> 1184</span>                        { <span class="keywordflow">return</span> item.second != (<span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> int)(first_i.intersect_line - lines_src.data())</div>
<div class="line"><span class="lineno"> 1185</span>                              &amp;&amp; item.second != (<span class="keywordtype">long</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(nearest_i.intersect_line - lines_src.data()); }),</div>
<div class="line"><span class="lineno"> 1186</span>                    std::back_inserter(closest));</div>
<div class="line"><span class="lineno"> 1187</span>                could_connect = closest.empty();</div>
<div class="line"><span class="lineno"> 1188</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 1189</span>                <span class="comment">// Avoid self intersections. Maybe it is better to trim the self intersection after the connection?</span></div>
<div class="line"><span class="lineno"> 1190</span>                <span class="keywordflow">if</span> (could_connect &amp;&amp; first_i.intersect_pl != nearest_i.intersect_pl) {</div>
<div class="line"><span class="lineno"> 1191</span>                    Line l(first_i_point, nearest_i_point);</div>
<div class="line"><span class="lineno"> 1192</span>                    could_connect = ! first_i.other_hook_intersects(l) &amp;&amp; ! nearest_i.other_hook_intersects(l);</div>
<div class="line"><span class="lineno"> 1193</span>                }</div>
<div class="line"><span class="lineno"> 1194</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1195</span>            }</div>
<div class="line"><span class="lineno"> 1196</span>            <span class="keywordtype">bool</span> connected = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1197</span>            <span class="keywordflow">if</span> (could_connect) {</div>
<div class="line"><span class="lineno"> 1198</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1199</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-connecting-pre-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point, nearest_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1200</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1201</span>                <span class="comment">// No other infill line intersects this anchor line. Extrude it as a whole.</span></div>
<div class="line"><span class="lineno"> 1202</span>                <span class="keywordflow">if</span> (first_i.intersect_pl == nearest_i.intersect_pl) {</div>
<div class="line"><span class="lineno"> 1203</span>                    <span class="comment">// Both intersections are on the same polyline, that means a loop is being closed.</span></div>
<div class="line"><span class="lineno"> 1204</span>                    assert(first_i.front != nearest_i.front);</div>
<div class="line"><span class="lineno"> 1205</span>                    <span class="keywordflow">if</span> (! first_i.front)</div>
<div class="line"><span class="lineno"> 1206</span>                        std::swap(first_i_point, nearest_i_point);</div>
<div class="line"><span class="lineno"> 1207</span>                    first_points.front() = first_i_point;</div>
<div class="line"><span class="lineno"> 1208</span>                    first_points.back()  = nearest_i_point;</div>
<div class="line"><span class="lineno"> 1209</span>                    <span class="comment">//FIXME trim the end of a closed loop a bit?</span></div>
<div class="line"><span class="lineno"> 1210</span>                    first_points.emplace(first_points.begin(), nearest_i_point);</div>
<div class="line"><span class="lineno"> 1211</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1212</span>                    <span class="comment">// Both intersections are on different polylines</span></div>
<div class="line"><span class="lineno"> 1213</span>                    Line  l(first_i_point, nearest_i_point);</div>
<div class="line"><span class="lineno"> 1214</span>                    l.translate((<a class="code hl_function" href="../../df/d4e/namespacelibnest2d_1_1pointlike.html#a52df9a1e4d9809d18fed21ccf4caae08">perp</a>(first_i.closest_line-&gt;vector().cast&lt;<span class="keywordtype">double</span>&gt;().normalized()) * (first_i.left ? scaled_trim_distance : - scaled_trim_distance)).<a class="code hl_function" href="../../d5/df7/_common_cwise_unary_ops_8h.html#aa89d007196125d10fa7d6e19811aca05">cast</a>&lt;<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>&gt;());</div>
<div class="line"><span class="lineno"> 1215</span>                    <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a> pt_start, pt_end;</div>
<div class="line"><span class="lineno"> 1216</span>                    <span class="keywordtype">bool</span>  trim_start = first_i  .intersect_pl-&gt;points.size() == 3 &amp;&amp; first_i  .other_hook_intersects(l, pt_start);</div>
<div class="line"><span class="lineno"> 1217</span>                    <span class="keywordtype">bool</span>  trim_end   = nearest_i.intersect_pl-&gt;points.size() == 3 &amp;&amp; nearest_i.other_hook_intersects(l, pt_end);</div>
<div class="line"><span class="lineno"> 1218</span>                    first_points.reserve(first_points.size() + second_points.size());</div>
<div class="line"><span class="lineno"> 1219</span>                    <span class="keywordflow">if</span> (first_i.front)</div>
<div class="line"><span class="lineno"> 1220</span>                        std::reverse(first_points.begin(), first_points.end());</div>
<div class="line"><span class="lineno"> 1221</span>                    <span class="keywordflow">if</span> (trim_start)</div>
<div class="line"><span class="lineno"> 1222</span>                        first_points.front() = pt_start;</div>
<div class="line"><span class="lineno"> 1223</span>                    first_points.back() = first_i_point;</div>
<div class="line"><span class="lineno"> 1224</span>                    first_points.emplace_back(nearest_i_point);</div>
<div class="line"><span class="lineno"> 1225</span>                    <span class="keywordflow">if</span> (nearest_i.front)</div>
<div class="line"><span class="lineno"> 1226</span>                        first_points.insert(first_points.end(), second_points.begin() + 1, second_points.end());</div>
<div class="line"><span class="lineno"> 1227</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1228</span>                        first_points.insert(first_points.end(), second_points.rbegin() + 1, second_points.rend());</div>
<div class="line"><span class="lineno"> 1229</span>                    <span class="keywordflow">if</span> (trim_end)</div>
<div class="line"><span class="lineno"> 1230</span>                        first_points.back() = pt_end;</div>
<div class="line"><span class="lineno"> 1231</span>                    <span class="comment">// Keep the polyline at the lower index slot.</span></div>
<div class="line"><span class="lineno"> 1232</span>                    <span class="keywordflow">if</span> (first_i.intersect_pl &lt; nearest_i.intersect_pl) {</div>
<div class="line"><span class="lineno"> 1233</span>                        second_points.clear();</div>
<div class="line"><span class="lineno"> 1234</span>                        merged_with[nearest_i.intersect_pl - lines.data()] = first_i.intersect_pl - lines.data();</div>
<div class="line"><span class="lineno"> 1235</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1236</span>                        second_points = std::move(first_points);</div>
<div class="line"><span class="lineno"> 1237</span>                        first_points.clear();</div>
<div class="line"><span class="lineno"> 1238</span>                        merged_with[first_i.intersect_pl - lines.data()] = nearest_i.intersect_pl - lines.data();</div>
<div class="line"><span class="lineno"> 1239</span>                    }</div>
<div class="line"><span class="lineno"> 1240</span>                }</div>
<div class="line"><span class="lineno"> 1241</span>                nearest_i.used = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1242</span>                connected = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1243</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1244</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-connecting-post-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point, nearest_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1245</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1246</span>            }</div>
<div class="line"><span class="lineno"> 1247</span>            <span class="keywordflow">if</span> (! connected) {</div>
<div class="line"><span class="lineno"> 1248</span>                <span class="comment">// Try to connect left or right. If not enough space for hook_length, take the longer side.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1250</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-add_hook-pre-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1251</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1252</span>                <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a8408e585ff5b07078360b31fd37a95e1">add_hook</a>(first_i, scaled_offset, hook_length, scaled_trim_distance, rtree, lines_src);</div>
<div class="line"><span class="lineno"> 1253</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1254</span>                export_infill_lines_to_svg(boundary, lines, <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">debug_out_path</a>(<span class="stringliteral">&quot;FillAdaptive-add_hook-post-%d-%d.svg&quot;</span>, iRun, iStep), { first_i.intersect_point });</div>
<div class="line"><span class="lineno"> 1255</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1256</span>            }</div>
<div class="line"><span class="lineno"> 1257</span><span class="preprocessor">#ifdef ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1258</span>            ++ iStep;</div>
<div class="line"><span class="lineno"> 1259</span><span class="preprocessor">#endif </span><span class="comment">// ADAPTIVE_CUBIC_INFILL_DEBUG_OUTPUT</span></div>
<div class="line"><span class="lineno"> 1260</span>            first_i.used = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1261</span>        }</div>
<div class="line"><span class="lineno"> 1262</span>    }</div>
<div class="line"><span class="lineno"> 1263</span> </div>
<div class="line"><span class="lineno"> 1264</span>    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> polylines_out;</div>
<div class="line"><span class="lineno"> 1265</span>    polylines_out.reserve(polylines_out.size() + std::count_if(lines.begin(), lines.end(), [](<span class="keyword">const</span> Polyline &amp;pl) { return !pl.empty(); }));</div>
<div class="line"><span class="lineno"> 1266</span>    <span class="keywordflow">for</span> (Polyline &amp;pl : lines)</div>
<div class="line"><span class="lineno"> 1267</span>        <a class="code hl_function" href="../../d8/d33/lexer_8c.html#ad4a65b873df5c05570846b5413b41dfd">if</a> (!pl.<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#aecabe174ebbb0e9cc7be41dafc297ef7">empty</a>()) polylines_out.emplace_back(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::move(pl));</div>
<div class="line"><span class="lineno"> 1268</span>    <span class="keywordflow">return</span> polylines_out;</div>
<div class="line"><span class="lineno"> 1269</span>}</div>
<div class="ttc" id="a_array_cwise_unary_ops_8h_html_a92b03396990b0e9eea0731aa406e31a4"><div class="ttname"><a href="../../d4/df0/_array_cwise_unary_ops_8h.html#a92b03396990b0e9eea0731aa406e31a4">cos</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC const CosReturnType cos() const</div><div class="ttdef"><b>Definition</b> ArrayCwiseUnaryOps.h:202</div></div>
<div class="ttc" id="a_common_cwise_unary_ops_8h_html_aa89d007196125d10fa7d6e19811aca05"><div class="ttname"><a href="../../d5/df7/_common_cwise_unary_ops_8h.html#aa89d007196125d10fa7d6e19811aca05">cast</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC CastXpr&lt; NewType &gt;::Type cast() const</div><div class="ttdef"><b>Definition</b> CommonCwiseUnaryOps.h:62</div></div>
<div class="ttc" id="aclass_slic3r_1_1_ex_polygon_html_a3fd4f1e86f356c9ac79dabfda8b43aec"><div class="ttname"><a href="../../db/dc4/class_slic3r_1_1_ex_polygon.html#a3fd4f1e86f356c9ac79dabfda8b43aec">Slic3r::ExPolygon::contour</a></div><div class="ttdeci">Polygon contour</div><div class="ttdef"><b>Definition</b> ExPolygon.hpp:35</div></div>
<div class="ttc" id="aclass_slic3r_1_1_multi_point_html_a5f33254e616268f728969886c4ed5d85"><div class="ttname"><a href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">Slic3r::MultiPoint::points</a></div><div class="ttdeci">Points points</div><div class="ttdef"><b>Definition</b> MultiPoint.hpp:18</div></div>
<div class="ttc" id="aclass_slic3r_1_1_polyline_html"><div class="ttname"><a href="../../d6/de0/class_slic3r_1_1_polyline.html">Slic3r::Polyline</a></div><div class="ttdef"><b>Definition</b> Polyline.hpp:17</div></div>
<div class="ttc" id="alexer_8c_html_ad4a65b873df5c05570846b5413b41dfd"><div class="ttname"><a href="../../d8/d33/lexer_8c.html#ad4a65b873df5c05570846b5413b41dfd">if</a></div><div class="ttdeci">if(!(yy_init))</div><div class="ttdef"><b>Definition</b> lexer.c:1190</div></div>
<div class="ttc" id="alibslic3r_8h_html_a299aabc5fc8285cbf99025330a3d0d0d"><div class="ttname"><a href="../../dd/d47/libslic3r_8h.html#a299aabc5fc8285cbf99025330a3d0d0d">PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition</b> libslic3r.h:58</div></div>
<div class="ttc" id="alibslic3r_8h_html_a5e7dd5d14b7e7bb8f1dab0fd4fa3e0f2"><div class="ttname"><a href="../../dd/d47/libslic3r_8h.html#a5e7dd5d14b7e7bb8f1dab0fd4fa3e0f2">scale_</a></div><div class="ttdeci">#define scale_(val)</div><div class="ttdef"><b>Definition</b> libslic3r.h:69</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a3e8df2806894ebc7012c77ec366d8525"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3e8df2806894ebc7012c77ec366d8525">Slic3r::FillAdaptive::validate_intersections</a></div><div class="ttdeci">bool validate_intersections(const std::vector&lt; Intersection &gt; &amp;intersections)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:792</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a62b6c3850ee31bb8711301708ef104a9"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a62b6c3850ee31bb8711301708ef104a9">Slic3r::FillAdaptive::validate_intersection_t_joint</a></div><div class="ttdeci">bool validate_intersection_t_joint(const Intersection &amp;intersection)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:780</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a677dfb88a4d21c1f2299b3c3a5db10b9"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">Slic3r::FillAdaptive::mk_rtree_point</a></div><div class="ttdeci">static rtree_point_t mk_rtree_point(const Point &amp;pt)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:658</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a7f035675898b5ecaf6f84d2f73260b94"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7f035675898b5ecaf6f84d2f73260b94">Slic3r::FillAdaptive::create_offset_line</a></div><div class="ttdeci">static Line create_offset_line(Line offset_line, const Intersection &amp;intersection, const double scaled_offset)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:641</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a8408e585ff5b07078360b31fd37a95e1"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a8408e585ff5b07078360b31fd37a95e1">Slic3r::FillAdaptive::add_hook</a></div><div class="ttdeci">static void add_hook(const Intersection &amp;intersection, const double scaled_offset, const coordf_t hook_length, double scaled_trim_distance, const rtree_t &amp;rtree, const Lines &amp;lines_src)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:669</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_ab790231e61a09b487d6d06f4ed7360e3"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ab790231e61a09b487d6d06f4ed7360e3">Slic3r::FillAdaptive::get_nearest_intersection</a></div><div class="ttdeci">static Intersection * get_nearest_intersection(std::vector&lt; std::pair&lt; Intersection *, double &gt; &gt; &amp;intersect_line, const size_t first_idx)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:619</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_ad5ef2163df60632bf830aa7ee39d43b7"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ad5ef2163df60632bf830aa7ee39d43b7">Slic3r::FillAdaptive::rtree_t</a></div><div class="ttdeci">bgi::rtree&lt; std::pair&lt; rtree_segment_t, size_t &gt;, bgi::rstar&lt; 16, 4 &gt; &gt; rtree_t</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:656</div></div>
<div class="ttc" id="anamespace_slic3r_1_1csg_html_a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24"><div class="ttname"><a href="../../d8/d2c/namespace_slic3r_1_1csg.html#a9ef7f4ffdd8a77b2ba27126e2c4f0b1caa06d31c2ee920b4d53e8c9c06d90ba24">Slic3r::csg::CSGType::Intersection</a></div><div class="ttdeci">@ Intersection</div></div>
<div class="ttc" id="anamespace_slic3r_html_a0913e2e6b7d28032c33cfee03f145fba"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a0913e2e6b7d28032c33cfee03f145fba">Slic3r::Lines</a></div><div class="ttdeci">std::vector&lt; Line &gt; Lines</div><div class="ttdef"><b>Definition</b> Line.hpp:17</div></div>
<div class="ttc" id="anamespace_slic3r_html_a1d1423286c406123371c37ceada9ebae"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a1d1423286c406123371c37ceada9ebae">Slic3r::debug_out_path</a></div><div class="ttdeci">std::string debug_out_path(const char *name,...)</div><div class="ttdef"><b>Definition</b> utils.cpp:218</div></div>
<div class="ttc" id="anamespace_slic3r_html_a498065f79ccb865fc410d4afeacffc9c"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Slic3r::Polylines</a></div><div class="ttdeci">std::vector&lt; Polyline &gt; Polylines</div><div class="ttdef"><b>Definition</b> Polyline.hpp:14</div></div>
<div class="ttc" id="anamespace_slic3r_html_a9f09756940b3eb2052058460bf07e4a3"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a9f09756940b3eb2052058460bf07e4a3">Slic3r::sqr</a></div><div class="ttdeci">constexpr T sqr(T x)</div><div class="ttdef"><b>Definition</b> libslic3r.h:258</div></div>
<div class="ttc" id="anamespace_slic3r_html_aa3af3ee03fdd2fbda072bbea6de1f8fc"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#aa3af3ee03fdd2fbda072bbea6de1f8fc">Slic3r::sort_remove_duplicates</a></div><div class="ttdeci">void sort_remove_duplicates(std::vector&lt; T &gt; &amp;vec)</div><div class="ttdef"><b>Definition</b> libslic3r.h:188</div></div>
<div class="ttc" id="anamespace_slic3r_html_aecabe174ebbb0e9cc7be41dafc297ef7"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#aecabe174ebbb0e9cc7be41dafc297ef7">Slic3r::empty</a></div><div class="ttdeci">bool empty(const BoundingBoxBase&lt; PointType, PointsType &gt; &amp;bb)</div><div class="ttdef"><b>Definition</b> BoundingBox.hpp:229</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1pointlike_html_a52df9a1e4d9809d18fed21ccf4caae08"><div class="ttname"><a href="../../df/d4e/namespacelibnest2d_1_1pointlike.html#a52df9a1e4d9809d18fed21ccf4caae08">libnest2d::pointlike::perp</a></div><div class="ttdeci">Pt perp(const Pt &amp;p)</div><div class="ttdef"><b>Definition</b> geometry_traits.hpp:335</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_a1e3d7fa98691c1716fe860ec229e2ff7"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a1e3d7fa98691c1716fe860ec229e2ff7">libnest2d::shapelike::contour</a></div><div class="ttdeci">Slic3r::Polygon &amp; contour(Slic3r::ExPolygon &amp;sh)</div><div class="ttdef"><b>Definition</b> geometries.hpp:216</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_ae1af6ac7a0feb7823506bcb23660a137"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae1af6ac7a0feb7823506bcb23660a137">libnest2d::shapelike::holes</a></div><div class="ttdeci">const THolesContainer&lt; PolygonImpl &gt; &amp; holes(const Slic3r::ExPolygon &amp;sh)</div><div class="ttdef"><b>Definition</b> geometries.hpp:189</div></div>
<div class="ttc" id="anamespacemarchsq_1_1____impl_html_a5c3960032271d7907677d3507c909780a0cc175b9c0f1b6a831c399e269772661"><div class="ttname"><a href="../../d9/d6c/namespacemarchsq_1_1____impl.html#a5c3960032271d7907677d3507c909780a0cc175b9c0f1b6a831c399e269772661">marchsq::__impl::SquareTag::a</a></div><div class="ttdeci">@ a</div></div>
<div class="ttc" id="anamespacemarchsq_1_1____impl_html_a5c3960032271d7907677d3507c909780a92eb5ffee6ae2fec3ad71c777531578f"><div class="ttname"><a href="../../d9/d6c/namespacemarchsq_1_1____impl.html#a5c3960032271d7907677d3507c909780a92eb5ffee6ae2fec3ad71c777531578f">marchsq::__impl::SquareTag::b</a></div><div class="ttdeci">@ b</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="../../d8/dcc/namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00197">Slic3r::Line::a</a>, <a class="el" href="../../#l00669">add_hook()</a>, <a class="el" href="../../#l00036">Slic3r::Polyline::append()</a>, <a class="el" href="../../#l00198">Slic3r::Line::b</a>, <a class="el" href="../../#l00070">Slic3r::MultiPoint::clear()</a>, <a class="el" href="../../#l00564">Slic3r::FillAdaptive::Intersection::closest_line</a>, <a class="el" href="../../#l00035">Slic3r::ExPolygon::contour</a>, <a class="el" href="../../#l00202">cos()</a>, <a class="el" href="../../#l00641">create_offset_line()</a>, <a class="el" href="../../#l00218">Slic3r::debug_out_path()</a>, <a class="el" href="../../#l00043">Slic3r::line_alg::distance_to_squared()</a>, <a class="el" href="../../#l00169">Slic3r::Line::distance_to_squared()</a>, <a class="el" href="../../#l00040">Slic3r::MultiPoint::empty()</a>, <a class="el" href="../../#l00580">Slic3r::FillAdaptive::Intersection::fresh()</a>, <a class="el" href="../../#l00573">Slic3r::FillAdaptive::Intersection::front</a>, <a class="el" href="../../#l00036">Slic3r::MultiPoint::front()</a>, <a class="el" href="../../#l00619">get_nearest_intersection()</a>, <a class="el" href="../../#l00036">Slic3r::ExPolygon::holes</a>, <a class="el" href="../../#l00567">Slic3r::FillAdaptive::Intersection::intersect_line</a>, <a class="el" href="../../#l00569">Slic3r::FillAdaptive::Intersection::intersect_pl</a>, <a class="el" href="../../#l00571">Slic3r::FillAdaptive::Intersection::intersect_point</a>, <a class="el" href="../../#l00092">Slic3r::Line::intersection()</a>, <a class="el" href="../../#l00686">Slic3r::intersection()</a>, <a class="el" href="../../#l00166">Slic3r::l2()</a>, <a class="el" href="../../#l00575">Slic3r::FillAdaptive::Intersection::left</a>, <a class="el" href="../../#l00022">Slic3r::Polyline::length()</a>, <a class="el" href="../../#l00658">mk_rtree_point()</a>, <a class="el" href="../../#l00661">mk_rtree_seg()</a>, <a class="el" href="../../#l00607">Slic3r::FillAdaptive::Intersection::other_hook_intersects()</a>, <a class="el" href="../../#l00104">Slic3r::perp()</a>, <a class="el" href="../../#l00058">PI</a>, <a class="el" href="../../#l00018">Slic3r::MultiPoint::points</a>, <a class="el" href="../../#l00034">Slic3r::MultiPoint::reverse()</a>, <a class="el" href="../../#l00069">scale_</a>, <a class="el" href="../../#l00071">SCALED_EPSILON</a>, <a class="el" href="../../#l00039">Slic3r::MultiPoint::size()</a>, <a class="el" href="../../#l00188">Slic3r::sort_remove_duplicates()</a>, <a class="el" href="../../#l00258">Slic3r::sqr()</a>, <a class="el" href="../../#l00161">Slic3r::Line::translate()</a>, <a class="el" href="../../#l00578">Slic3r::FillAdaptive::Intersection::used</a>, <a class="el" href="../../#l00780">validate_intersection_t_joint()</a>, <a class="el" href="../../#l00792">validate_intersections()</a>, and <a class="el" href="../../#l00181">Slic3r::Line::vector()</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_afb2f3cac794562525dd4a5ea6cc44fec_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a7f035675898b5ecaf6f84d2f73260b94" name="a7f035675898b5ecaf6f84d2f73260b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f035675898b5ecaf6f84d2f73260b94">&#9670;&#160;</a></span>create_offset_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a> Slic3r::FillAdaptive::create_offset_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a>&#160;</td>
          <td class="paramname"><em>offset_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> double&#160;</td>
          <td class="paramname"><em>scaled_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  642</span>{</div>
<div class="line"><span class="lineno">  643</span>    offset_line.<a class="code hl_function" href="../../d6/d3b/class_slic3r_1_1_line.html#a431ce615156442654d037af0915b71c8">translate</a>((perp(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;vector().cast&lt;<span class="keywordtype">double</span>&gt;().normalized()) * (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.left ? scaled_offset : - scaled_offset)).<a class="code hl_function" href="../../d5/df7/_common_cwise_unary_ops_8h.html#aa89d007196125d10fa7d6e19811aca05">cast</a>&lt;<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>&gt;());</div>
<div class="line"><span class="lineno">  644</span>    <span class="comment">// Extend the line by a small value to guarantee a collision with adjacent lines</span></div>
<div class="line"><span class="lineno">  645</span>    offset_line.<a class="code hl_function" href="../../d6/d3b/class_slic3r_1_1_line.html#a544b63768f49041a63e46ed6eff49011">extend</a>(<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>(scaled_offset * 1.16)); <span class="comment">// / cos(PI/6)</span></div>
<div class="line"><span class="lineno">  646</span>    <span class="keywordflow">return</span> offset_line;</div>
<div class="line"><span class="lineno">  647</span>}</div>
<div class="ttc" id="aclass_slic3r_1_1_line_html_a431ce615156442654d037af0915b71c8"><div class="ttname"><a href="../../d6/d3b/class_slic3r_1_1_line.html#a431ce615156442654d037af0915b71c8">Slic3r::Line::translate</a></div><div class="ttdeci">void translate(const Point &amp;v)</div><div class="ttdef"><b>Definition</b> Line.hpp:161</div></div>
<div class="ttc" id="aclass_slic3r_1_1_line_html_a544b63768f49041a63e46ed6eff49011"><div class="ttname"><a href="../../d6/d3b/class_slic3r_1_1_line.html#a544b63768f49041a63e46ed6eff49011">Slic3r::Line::extend</a></div><div class="ttdeci">void extend(double offset)</div><div class="ttdef"><b>Definition</b> Line.cpp:108</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00108">Slic3r::Line::extend()</a>, <a class="el" href="../../#l00686">Slic3r::intersection()</a>, <a class="el" href="../../#l00104">Slic3r::perp()</a>, and <a class="el" href="../../#l00161">Slic3r::Line::translate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00669">add_hook()</a>, and <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a7f035675898b5ecaf6f84d2f73260b94_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a7f035675898b5ecaf6f84d2f73260b94_icgraph.svg" width="559" height="82"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae29454fb8b1d346b05eb37d19d0c8a4b" name="ae29454fb8b1d346b05eb37d19d0c8a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29454fb8b1d346b05eb37d19d0c8a4b">&#9670;&#160;</a></span>generate_infill_lines_recursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> Slic3r::FillAdaptive::generate_infill_lines_recursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html">FillContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  455</span>{</div>
<div class="line"><span class="lineno">  456</span>    assert(<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a> != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>    <span class="keyword">const</span> std::vector&lt;CubeProperties&gt; &amp;cubes_properties = context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a23c0f89314309dd83752f68bc4e15f5f">cubes_properties</a>;</div>
<div class="line"><span class="lineno">  459</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> z_diff     = context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#aecd9bf59670dc9e7639256827550c6a3">z_position</a> - <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;center.z();</div>
<div class="line"><span class="lineno">  460</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> z_diff_abs = std::abs(z_diff);</div>
<div class="line"><span class="lineno">  461</span> </div>
<div class="line"><span class="lineno">  462</span>    <span class="keywordflow">if</span> (z_diff_abs &gt; cubes_properties[depth].height / 2.)</div>
<div class="line"><span class="lineno">  463</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>    <span class="keywordflow">if</span> (z_diff_abs &lt; cubes_properties[depth].line_z_distance) {</div>
<div class="line"><span class="lineno">  466</span>        <span class="comment">// Discretize a single wall splitting the cube into two.</span></div>
<div class="line"><span class="lineno">  467</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> zdist = cubes_properties[depth].line_z_distance;</div>
<div class="line"><span class="lineno">  468</span>        <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> from(</div>
<div class="line"><span class="lineno">  469</span>            0.5 * cubes_properties[depth].diagonal_length * (zdist - z_diff_abs) / zdist,</div>
<div class="line"><span class="lineno">  470</span>            cubes_properties[depth].line_xy_distance - (zdist + z_diff) / <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(2.));</div>
<div class="line"><span class="lineno">  471</span>        <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> to(-from.x(), from.y());</div>
<div class="line"><span class="lineno">  472</span>        from = context.<a class="code hl_function" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a366c904b24e896a7528778e149ec3e54">rotate</a>(from);</div>
<div class="line"><span class="lineno">  473</span>        to   = context.<a class="code hl_function" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a366c904b24e896a7528778e149ec3e54">rotate</a>(to);</div>
<div class="line"><span class="lineno">  474</span>        <span class="comment">// Relative to cube center</span></div>
<div class="line"><span class="lineno">  475</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a> offset(<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;center.x(), <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;center.y());</div>
<div class="line"><span class="lineno">  476</span>        from += offset;</div>
<div class="line"><span class="lineno">  477</span>        to   += offset;</div>
<div class="line"><span class="lineno">  478</span>        <span class="comment">// Verify that the traversal order of the octree children matches the line direction,</span></div>
<div class="line"><span class="lineno">  479</span>        <span class="comment">// therefore the infill line may get extended with O(1) time &amp; space complexity.</span></div>
<div class="line"><span class="lineno">  480</span>        assert(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a14a6caaeff32208a7480ba764336689f">verify_traversal_order</a>(context, <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>, depth, from, to));</div>
<div class="line"><span class="lineno">  481</span>        <span class="comment">// Either extend an existing line or start a new one.</span></div>
<div class="line"><span class="lineno">  482</span>        <a class="code hl_class" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a> &amp;last_line = context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a7e17b17e7630887482f7be192c1f0d27">temp_lines</a>[address];</div>
<div class="line"><span class="lineno">  483</span>        <a class="code hl_class" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a>  new_line(Point::new_scale(from), Point::new_scale(to));</div>
<div class="line"><span class="lineno">  484</span>        <span class="keywordflow">if</span> (last_line.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#aca852d5b90bfa7a0ed8ae5a5b7e75e82">a</a>.x() == std::numeric_limits&lt;coord_t&gt;::max()) {</div>
<div class="line"><span class="lineno">  485</span>            last_line.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#aca852d5b90bfa7a0ed8ae5a5b7e75e82">a</a> = new_line.a;</div>
<div class="line"><span class="lineno">  486</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((new_line.a - last_line.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#a8ed125162ca54cb677868a59b014747a">b</a>).cwiseAbs().maxCoeff() &gt; 1000) { <span class="comment">// SCALED_EPSILON is 100 and it is not enough</span></div>
<div class="line"><span class="lineno">  487</span>            context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#ade4d083308cedc5729313d3dbb0f385b">output_lines</a>.emplace_back(last_line);</div>
<div class="line"><span class="lineno">  488</span>            last_line.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#aca852d5b90bfa7a0ed8ae5a5b7e75e82">a</a> = new_line.a;</div>
<div class="line"><span class="lineno">  489</span>        }</div>
<div class="line"><span class="lineno">  490</span>        last_line.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#a8ed125162ca54cb677868a59b014747a">b</a> = new_line.b;</div>
<div class="line"><span class="lineno">  491</span>    }</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    <span class="comment">// left child index</span></div>
<div class="line"><span class="lineno">  494</span>    address = address * 2 + 1;</div>
<div class="line"><span class="lineno">  495</span>    -- depth;</div>
<div class="line"><span class="lineno">  496</span>    <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><span class="lineno">  497</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">int</span> child_idx : context.traversal_order) {</div>
<div class="line"><span class="lineno">  498</span>        <span class="keyword">const</span> Cube *child = <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;children[child_idx];</div>
<div class="line"><span class="lineno">  499</span>        <span class="keywordflow">if</span> (child != <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  500</span>            <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ae29454fb8b1d346b05eb37d19d0c8a4b">generate_infill_lines_recursive</a>(context, child, address, depth);</div>
<div class="line"><span class="lineno">  501</span>        <span class="keywordflow">if</span> (++ i == 4)</div>
<div class="line"><span class="lineno">  502</span>            <span class="comment">// right child index</span></div>
<div class="line"><span class="lineno">  503</span>            ++ address;</div>
<div class="line"><span class="lineno">  504</span>    }</div>
<div class="line"><span class="lineno">  505</span>}</div>
<div class="ttc" id="a_array_cwise_unary_ops_8h_html_a656b9217a2fcb6de59dc8d1eb3079cc7"><div class="ttname"><a href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC const SqrtReturnType sqrt() const</div><div class="ttdef"><b>Definition</b> ArrayCwiseUnaryOps.h:152</div></div>
<div class="ttc" id="a_array_cwise_unary_ops_8h_html_ad816d4a0c05f21e660e91e9febb1b900"><div class="ttname"><a href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC const CubeReturnType cube() const</div><div class="ttdef"><b>Definition</b> ArrayCwiseUnaryOps.h:360</div></div>
<div class="ttc" id="aclass_slic3r_1_1_line_html_a8ed125162ca54cb677868a59b014747a"><div class="ttname"><a href="../../d6/d3b/class_slic3r_1_1_line.html#a8ed125162ca54cb677868a59b014747a">Slic3r::Line::b</a></div><div class="ttdeci">Point b</div><div class="ttdef"><b>Definition</b> Line.hpp:198</div></div>
<div class="ttc" id="aclass_slic3r_1_1_line_html_aca852d5b90bfa7a0ed8ae5a5b7e75e82"><div class="ttname"><a href="../../d6/d3b/class_slic3r_1_1_line.html#aca852d5b90bfa7a0ed8ae5a5b7e75e82">Slic3r::Line::a</a></div><div class="ttdeci">Point a</div><div class="ttdef"><b>Definition</b> Line.hpp:197</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a14a6caaeff32208a7480ba764336689f"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a14a6caaeff32208a7480ba764336689f">Slic3r::FillAdaptive::verify_traversal_order</a></div><div class="ttdeci">static bool verify_traversal_order(FillContext &amp;context, const Cube *cube, int depth, const Vec2d &amp;line_from, const Vec2d &amp;line_to)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:415</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_ae29454fb8b1d346b05eb37d19d0c8a4b"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#ae29454fb8b1d346b05eb37d19d0c8a4b">Slic3r::FillAdaptive::generate_infill_lines_recursive</a></div><div class="ttdeci">static void generate_infill_lines_recursive(FillContext &amp;context, const Cube *cube, int address, int depth)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:449</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_a23c0f89314309dd83752f68bc4e15f5f"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a23c0f89314309dd83752f68bc4e15f5f">Slic3r::FillAdaptive::FillContext::cubes_properties</a></div><div class="ttdeci">const std::vector&lt; CubeProperties &gt; &amp; cubes_properties</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:384</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_a366c904b24e896a7528778e149ec3e54"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a366c904b24e896a7528778e149ec3e54">Slic3r::FillAdaptive::FillContext::rotate</a></div><div class="ttdeci">Vec2d rotate(const Vec2d &amp;v)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:382</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_a7e17b17e7630887482f7be192c1f0d27"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a7e17b17e7630887482f7be192c1f0d27">Slic3r::FillAdaptive::FillContext::temp_lines</a></div><div class="ttdeci">std::vector&lt; Line &gt; temp_lines</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:395</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_ade4d083308cedc5729313d3dbb0f385b"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#ade4d083308cedc5729313d3dbb0f385b">Slic3r::FillAdaptive::FillContext::output_lines</a></div><div class="ttdeci">std::vector&lt; Line &gt; output_lines</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:397</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_aecd9bf59670dc9e7639256827550c6a3"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#aecd9bf59670dc9e7639256827550c6a3">Slic3r::FillAdaptive::FillContext::z_position</a></div><div class="ttdeci">const double z_position</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:386</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00197">Slic3r::Line::a</a>, <a class="el" href="../../#l00198">Slic3r::Line::b</a>, <a class="el" href="../../#l00360">cube()</a>, <a class="el" href="../../#l00384">Slic3r::FillAdaptive::FillContext::cubes_properties</a>, <a class="el" href="../../#l00449">generate_infill_lines_recursive()</a>, <a class="el" href="../../#l00416">Slic3r::offset()</a>, <a class="el" href="../../#l00397">Slic3r::FillAdaptive::FillContext::output_lines</a>, <a class="el" href="../../#l00382">Slic3r::FillAdaptive::FillContext::rotate()</a>, <a class="el" href="../../#l00152">sqrt()</a>, <a class="el" href="../../#l00395">Slic3r::FillAdaptive::FillContext::temp_lines</a>, <a class="el" href="../../#l00388">Slic3r::FillAdaptive::FillContext::traversal_order</a>, <a class="el" href="../../#l00415">verify_traversal_order()</a>, and <a class="el" href="../../#l00386">Slic3r::FillAdaptive::FillContext::z_position</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01320">Slic3r::FillAdaptive::Filler::_fill_surface_single()</a>, and <a class="el" href="../../#l00449">generate_infill_lines_recursive()</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ae29454fb8b1d346b05eb37d19d0c8a4b_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ae29454fb8b1d346b05eb37d19d0c8a4b_icgraph.svg" width="338" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab790231e61a09b487d6d06f4ed7360e3" name="ab790231e61a09b487d6d06f4ed7360e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab790231e61a09b487d6d06f4ed7360e3">&#9670;&#160;</a></span>get_nearest_intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> * Slic3r::FillAdaptive::get_nearest_intersection </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> *, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersect_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> size_t&#160;</td>
          <td class="paramname"><em>first_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  620</span>{</div>
<div class="line"><span class="lineno">  621</span>    assert(intersect_line.size() &gt;= 2);</div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordtype">bool</span> take_next = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">if</span> (first_idx == 0)</div>
<div class="line"><span class="lineno">  624</span>        take_next = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  625</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first_idx + 1 == intersect_line.size())</div>
<div class="line"><span class="lineno">  626</span>        take_next = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  627</span>    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  628</span>        <span class="comment">// Has both prev and next.</span></div>
<div class="line"><span class="lineno">  629</span>        <span class="keyword">const</span> std::pair&lt;Intersection*, double&gt; &amp;ithis = intersect_line[first_idx];</div>
<div class="line"><span class="lineno">  630</span>        <span class="keyword">const</span> std::pair&lt;Intersection*, double&gt; &amp;iprev = intersect_line[first_idx - 1];</div>
<div class="line"><span class="lineno">  631</span>        <span class="keyword">const</span> std::pair&lt;Intersection*, double&gt; &amp;inext = intersect_line[first_idx + 1];</div>
<div class="line"><span class="lineno">  632</span>        take_next = iprev.first-&gt;fresh() &amp;&amp; inext.first-&gt;fresh() ?</div>
<div class="line"><span class="lineno">  633</span>            inext.second - ithis.second &lt; ithis.second - iprev.second :</div>
<div class="line"><span class="lineno">  634</span>            inext.first-&gt;fresh();</div>
<div class="line"><span class="lineno">  635</span>    }</div>
<div class="line"><span class="lineno">  636</span>    <span class="keywordflow">return</span> intersect_line[take_next ? first_idx + 1 : first_idx - 1].first;</div>
<div class="line"><span class="lineno">  637</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ab790231e61a09b487d6d06f4ed7360e3_icgraph.svg" width="420" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae2321a9111541715a8960f6b3311d146" name="ae2321a9111541715a8960f6b3311d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2321a9111541715a8960f6b3311d146">&#9670;&#160;</a></span>has_no_collinear_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Slic3r::FillAdaptive::has_no_collinear_lines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a498065f79ccb865fc410d4afeacffc9c">Polylines</a> &amp;&#160;</td>
          <td class="paramname"><em>polylines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1273</span>{</div>
<div class="line"><span class="lineno"> 1274</span>    <span class="comment">// Create line end point lookup.</span></div>
<div class="line"><span class="lineno"> 1275</span>    <span class="keyword">struct </span>LineEnd {</div>
<div class="line"><span class="lineno"> 1276</span>        LineEnd(<span class="keyword">const</span> <a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a> *line, <span class="keywordtype">bool</span> start) : line(line), start(start) {}</div>
<div class="line"><span class="lineno"> 1277</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d6/de0/class_slic3r_1_1_polyline.html">Polyline</a> *line;</div>
<div class="line"><span class="lineno"> 1278</span>        <span class="comment">// Is it the start or end point?</span></div>
<div class="line"><span class="lineno"> 1279</span>        <span class="keywordtype">bool</span>            start;</div>
<div class="line"><span class="lineno"> 1280</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a>&amp;    point()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> start ? line-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.front() : line-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back(); }</div>
<div class="line"><span class="lineno"> 1281</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a>&amp;    other_point()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> start ? line-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.back() : line-&gt;<a class="code hl_variable" href="../../d7/dd1/class_slic3r_1_1_multi_point.html#a5f33254e616268f728969886c4ed5d85">points</a>.front(); }</div>
<div class="line"><span class="lineno"> 1282</span>        LineEnd         other_end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> LineEnd(line, !start); }</div>
<div class="line"><span class="lineno"> 1283</span>        <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>           vec()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a>((this-&gt;other_point() - this-&gt;point()).cast&lt;double&gt;()); }</div>
<div class="line"><span class="lineno"> 1284</span>        <span class="keywordtype">bool</span> <a class="code hl_function" href="../../de/d37/namespace_clipper_lib.html#a3a668d17d095899718edc971956848ca">operator==</a>(<span class="keyword">const</span> LineEnd &amp;rhs)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;line == rhs.line &amp;&amp; this-&gt;start == rhs.start; }</div>
<div class="line"><span class="lineno"> 1285</span>    };</div>
<div class="line"><span class="lineno"> 1286</span>    <span class="keyword">struct </span>LineEndAccessor {</div>
<div class="line"><span class="lineno"> 1287</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../d8/d9b/point__areas_8cpp.html#a6a2f109ab3e0aba2f61e7d28188c3660">Point</a>* operator()(<span class="keyword">const</span> LineEnd &amp;pt)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;pt.point(); }</div>
<div class="line"><span class="lineno"> 1288</span>    };</div>
<div class="line"><span class="lineno"> 1289</span>    <span class="keyword">typedef</span> ClosestPointInRadiusLookup&lt;LineEnd, LineEndAccessor&gt; ClosestPointLookupType;</div>
<div class="line"><span class="lineno"> 1290</span>    ClosestPointLookupType closest_end_point_lookup(<a class="code hl_typedef" href="../../dd/d47/libslic3r_8h.html#a8a7f69c27280e7542b2d1fd979af4545">coord_t</a>(1001. * <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(2.)));</div>
<div class="line"><span class="lineno"> 1291</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> Polyline&amp; pl : polylines) {</div>
<div class="line"><span class="lineno"> 1292</span><span class="comment">//        assert(pl.points.size() == 2);</span></div>
<div class="line"><span class="lineno"> 1293</span>        <span class="keyword">auto</span> line_start = LineEnd(&amp;pl, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1294</span>        <span class="keyword">auto</span> line_end   = LineEnd(&amp;pl, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1295</span> </div>
<div class="line"><span class="lineno"> 1296</span>        <span class="keyword">auto</span> assert_not_collinear = [&amp;closest_end_point_lookup](<span class="keyword">const</span> LineEnd &amp;line_start) {</div>
<div class="line"><span class="lineno"> 1297</span>            std::vector&lt;std::pair&lt;const LineEnd*, double&gt;&gt; hits = closest_end_point_lookup.find_all(line_start.point());</div>
<div class="line"><span class="lineno"> 1298</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const LineEnd*, double&gt; &amp;hit : hits)</div>
<div class="line"><span class="lineno"> 1299</span>                <a class="code hl_function" href="../../d8/d33/lexer_8c.html#ad4a65b873df5c05570846b5413b41dfd">if</a> ((line_start.point() - hit.first-&gt;point()).<a class="code hl_function" href="../../d0/d5f/_matrix_cwise_unary_ops_8h.html#afaccb60c8e7e930b441a048374b64ea3">cwiseAbs</a>().maxCoeff() &lt;= 1000) {</div>
<div class="line"><span class="lineno"> 1300</span>                    <span class="comment">// End points of the two lines are very close, they should have been merged together if they are collinear.</span></div>
<div class="line"><span class="lineno"> 1301</span>                    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> v1 = line_start.vec();</div>
<div class="line"><span class="lineno"> 1302</span>                    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> v2 = hit.first-&gt;vec();</div>
<div class="line"><span class="lineno"> 1303</span>                    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> v1n = v1.normalized();</div>
<div class="line"><span class="lineno"> 1304</span>                    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> v2n = v2.normalized();</div>
<div class="line"><span class="lineno"> 1305</span>                    <span class="comment">// The vectors must not be collinear.</span></div>
<div class="line"><span class="lineno"> 1306</span>                    assert(std::abs(v1n.dot(v2n)) &lt; <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a92b03396990b0e9eea0731aa406e31a4">cos</a>(<a class="code hl_define" href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 12.));</div>
<div class="line"><span class="lineno"> 1307</span>                }</div>
<div class="line"><span class="lineno"> 1308</span>        };</div>
<div class="line"><span class="lineno"> 1309</span>        assert_not_collinear(line_start);</div>
<div class="line"><span class="lineno"> 1310</span>        assert_not_collinear(line_end);</div>
<div class="line"><span class="lineno"> 1311</span> </div>
<div class="line"><span class="lineno"> 1312</span>        closest_end_point_lookup.insert(line_start);</div>
<div class="line"><span class="lineno"> 1313</span>        closest_end_point_lookup.insert(line_end);</div>
<div class="line"><span class="lineno"> 1314</span>    }</div>
<div class="line"><span class="lineno"> 1315</span> </div>
<div class="line"><span class="lineno"> 1316</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1317</span>}</div>
<div class="ttc" id="a_extrusion_simulator_8cpp_html_ae71449b1cc6e6250b91f539153a7a0d3"><div class="ttname"><a href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></div><div class="ttdeci">#define M_PI</div><div class="ttdef"><b>Definition</b> ExtrusionSimulator.cpp:20</div></div>
<div class="ttc" id="a_matrix_cwise_unary_ops_8h_html_afaccb60c8e7e930b441a048374b64ea3"><div class="ttname"><a href="../../d0/d5f/_matrix_cwise_unary_ops_8h.html#afaccb60c8e7e930b441a048374b64ea3">cwiseAbs</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CwiseAbsReturnType cwiseAbs() const</div><div class="ttdef"><b>Definition</b> MatrixCwiseUnaryOps.h:32</div></div>
<div class="ttc" id="anamespace_clipper_lib_html_a3a668d17d095899718edc971956848ca"><div class="ttname"><a href="../../de/d37/namespace_clipper_lib.html#a3a668d17d095899718edc971956848ca">ClipperLib::operator==</a></div><div class="ttdeci">bool operator==(const IntPoint &amp;l, const IntPoint &amp;r)</div><div class="ttdef"><b>Definition</b> clipper.cpp:93</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00202">cos()</a>, <a class="el" href="../../#l00020">M_PI</a>, <a class="el" href="../../#l00018">Slic3r::MultiPoint::points</a>, and <a class="el" href="../../#l00152">sqrt()</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ae2321a9111541715a8960f6b3311d146_cgraph.svg" width="263" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a112dfa9d85d9dd3843e71c52e493f971" name="a112dfa9d85d9dd3843e71c52e493f971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112dfa9d85d9dd3843e71c52e493f971">&#9670;&#160;</a></span>is_overhang_triangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slic3r::FillAdaptive::is_overhang_triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1448</span>{</div>
<div class="line"><span class="lineno"> 1449</span>    <span class="comment">// Calculate triangle normal.</span></div>
<div class="line"><span class="lineno"> 1450</span>    <span class="keyword">auto</span> n = (b - a).cross(c - b);</div>
<div class="line"><span class="lineno"> 1451</span>    <span class="keywordflow">return</span> n.dot(up) &gt; 0.707 * n.norm();</div>
<div class="line"><span class="lineno"> 1452</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l01447">is_overhang_triangle()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01465">build_octree()</a>, and <a class="el" href="../../#l01447">is_overhang_triangle()</a>.</p>
<div id="dynsection-12" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-12-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a112dfa9d85d9dd3843e71c52e493f971_cgraph.svg" width="159" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-13" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-13-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a112dfa9d85d9dd3843e71c52e493f971_icgraph.svg" width="516" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab8b1d64bf2fbe2f31e06e70cfe6d33cf" name="ab8b1d64bf2fbe2f31e06e70cfe6d33cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b1d64bf2fbe2f31e06e70cfe6d33cf">&#9670;&#160;</a></span>make_cubes_properties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">CubeProperties</a> &gt; Slic3r::FillAdaptive::make_cubes_properties </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_cube_edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>line_spacing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1428</span>{</div>
<div class="line"><span class="lineno"> 1429</span>    max_cube_edge_length += <a class="code hl_variable" href="../../dd/d47/libslic3r_8h.html#a75f355966e0a97665eaf5a4c79baa7af">EPSILON</a>;</div>
<div class="line"><span class="lineno"> 1430</span> </div>
<div class="line"><span class="lineno"> 1431</span>    std::vector&lt;CubeProperties&gt; cubes_properties;</div>
<div class="line"><span class="lineno"> 1432</span>    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> edge_length = line_spacing * 2.;; edge_length *= 2.)</div>
<div class="line"><span class="lineno"> 1433</span>    {</div>
<div class="line"><span class="lineno"> 1434</span>        <a class="code hl_struct" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">CubeProperties</a> props{};</div>
<div class="line"><span class="lineno"> 1435</span>        props.<a class="code hl_variable" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aeb308403d196d1a9fb441fa326d424d7">edge_length</a> = edge_length;</div>
<div class="line"><span class="lineno"> 1436</span>        props.height = edge_length * <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(3);</div>
<div class="line"><span class="lineno"> 1437</span>        props.diagonal_length = edge_length * <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(2);</div>
<div class="line"><span class="lineno"> 1438</span>        props.line_z_distance = edge_length / <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(3);</div>
<div class="line"><span class="lineno"> 1439</span>        props.line_xy_distance = edge_length / <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a656b9217a2fcb6de59dc8d1eb3079cc7">sqrt</a>(6);</div>
<div class="line"><span class="lineno"> 1440</span>        cubes_properties.emplace_back(props);</div>
<div class="line"><span class="lineno"> 1441</span>        <span class="keywordflow">if</span> (edge_length &gt; max_cube_edge_length)</div>
<div class="line"><span class="lineno"> 1442</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1443</span>    }</div>
<div class="line"><span class="lineno"> 1444</span>    <span class="keywordflow">return</span> cubes_properties;</div>
<div class="line"><span class="lineno"> 1445</span>}</div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_aeb308403d196d1a9fb441fa326d424d7"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#aeb308403d196d1a9fb441fa326d424d7">Slic3r::FillAdaptive::CubeProperties::edge_length</a></div><div class="ttdeci">double edge_length</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:250</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#da/deb/struct_slic3r_1_1_fill_adaptive_1_1_cube_properties">Slic3r::FillAdaptive::CubeProperties</a></div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:249</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00250">Slic3r::FillAdaptive::CubeProperties::edge_length</a>, <a class="el" href="../../#l00051">EPSILON</a>, <a class="el" href="../../#l01427">make_cubes_properties()</a>, and <a class="el" href="../../#l00152">sqrt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01465">build_octree()</a>, and <a class="el" href="../../#l01427">make_cubes_properties()</a>.</p>
<div id="dynsection-14" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-14-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-14-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-14-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ab8b1d64bf2fbe2f31e06e70cfe6d33cf_cgraph.svg" width="270" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-15" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-15-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-15-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-15-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_ab8b1d64bf2fbe2f31e06e70cfe6d33cf_icgraph.svg" width="535" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a677dfb88a4d21c1f2299b3c3a5db10b9" name="a677dfb88a4d21c1f2299b3c3a5db10b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677dfb88a4d21c1f2299b3c3a5db10b9">&#9670;&#160;</a></span>mk_rtree_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a> Slic3r::FillAdaptive::mk_rtree_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  658</span>                                                            {</div>
<div class="line"><span class="lineno">  659</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">rtree_point_t</a>(<span class="keywordtype">float</span>(pt.x()), <span class="keywordtype">float</span>(pt.y()));</div>
<div class="line"><span class="lineno">  660</span>}</div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a4bea6f8de479db81e6d18ec53d5f73b6"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a4bea6f8de479db81e6d18ec53d5f73b6">Slic3r::FillAdaptive::rtree_point_t</a></div><div class="ttdeci">bgm::point&lt; float, 2, boost::geometry::cs::cartesian &gt; rtree_point_t</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:654</div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>, and <a class="el" href="../../#l00661">mk_rtree_seg()</a>.</p>
<div id="dynsection-16" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-16-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-16-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-16-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a677dfb88a4d21c1f2299b3c3a5db10b9_icgraph.svg" width="100%" height="431"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aa4dfe0f03a13cfd3a7352d3cfa2b8fe7" name="aa4dfe0f03a13cfd3a7352d3cfa2b8fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dfe0f03a13cfd3a7352d3cfa2b8fe7">&#9670;&#160;</a></span>mk_rtree_seg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a> Slic3r::FillAdaptive::mk_rtree_seg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/d3b/class_slic3r_1_1_line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  664</span>                                                          {</div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#af636d8557376a74c109bb61f8ebeb8d3">mk_rtree_seg</a>(l.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#aca852d5b90bfa7a0ed8ae5a5b7e75e82">a</a>, l.<a class="code hl_variable" href="../../d6/d3b/class_slic3r_1_1_line.html#a8ed125162ca54cb677868a59b014747a">b</a>);</div>
<div class="line"><span class="lineno">  666</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00197">Slic3r::Line::a</a>, <a class="el" href="../../#l00198">Slic3r::Line::b</a>, and <a class="el" href="../../#l00661">mk_rtree_seg()</a>.</p>
<div id="dynsection-17" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-17-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-17-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-17-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_aa4dfe0f03a13cfd3a7352d3cfa2b8fe7_cgraph.svg" width="498" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af636d8557376a74c109bb61f8ebeb8d3" name="af636d8557376a74c109bb61f8ebeb8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af636d8557376a74c109bb61f8ebeb8d3">&#9670;&#160;</a></span>mk_rtree_seg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a7c6a11139ccb39e953a4f28a21ea0961">rtree_segment_t</a> Slic3r::FillAdaptive::mk_rtree_seg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d6/dec/class_slic3r_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  661</span>                                                                           {</div>
<div class="line"><span class="lineno">  662</span>    <span class="keywordflow">return</span> { <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">mk_rtree_point</a>(a), <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a677dfb88a4d21c1f2299b3c3a5db10b9">mk_rtree_point</a>(b) };</div>
<div class="line"><span class="lineno">  663</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00658">mk_rtree_point()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00669">add_hook()</a>, <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>, and <a class="el" href="../../#l00664">mk_rtree_seg()</a>.</p>
<div id="dynsection-18" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-18-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-18-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-18-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_af636d8557376a74c109bb61f8ebeb8d3_cgraph.svg" width="320" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-19" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-19-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-19-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-19-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_af636d8557376a74c109bb61f8ebeb8d3_icgraph.svg" width="558" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9db146374c8ace3e761fde2bd71e8aea" name="a9db146374c8ace3e761fde2bd71e8aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db146374c8ace3e761fde2bd71e8aea">&#9670;&#160;</a></span>transform_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> Slic3r::FillAdaptive::transform_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *&#160;</td>
          <td class="paramname"><em>current_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1455</span>{</div>
<div class="line"><span class="lineno"> 1456</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno"> 1457</span>    current_cube-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a9f67f038ab3c7e02119b795e28ad6c64">center_octree</a> = current_cube-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">center</a>;</div>
<div class="line"><span class="lineno"> 1458</span><span class="preprocessor">#endif </span><span class="comment">// NDEBUG</span></div>
<div class="line"><span class="lineno"> 1459</span>    current_cube-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">center</a> = rot * current_cube-&gt;<a class="code hl_variable" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a3699025a7d1dbec009345b4ba5f30ea2">center</a>;</div>
<div class="line"><span class="lineno"> 1460</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> *child : current_cube-&gt;children)</div>
<div class="line"><span class="lineno"> 1461</span>        <a class="code hl_function" href="../../d8/d33/lexer_8c.html#ad4a65b873df5c05570846b5413b41dfd">if</a> (child)</div>
<div class="line"><span class="lineno"> 1462</span>            <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a9db146374c8ace3e761fde2bd71e8aea">transform_center</a>(child, rot);</div>
<div class="line"><span class="lineno"> 1463</span>}</div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a9db146374c8ace3e761fde2bd71e8aea"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a9db146374c8ace3e761fde2bd71e8aea">Slic3r::FillAdaptive::transform_center</a></div><div class="ttdeci">static void transform_center(Cube *current_cube, const Eigen::Matrix3d &amp;rot)</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:1454</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_cube_html_a9f67f038ab3c7e02119b795e28ad6c64"><div class="ttname"><a href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html#a9f67f038ab3c7e02119b795e28ad6c64">Slic3r::FillAdaptive::Cube::center_octree</a></div><div class="ttdeci">Vec3d center_octree</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:242</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00240">Slic3r::FillAdaptive::Cube::center</a>, <a class="el" href="../../#l00242">Slic3r::FillAdaptive::Cube::center_octree</a>, <a class="el" href="../../#l00244">Slic3r::FillAdaptive::Cube::children</a>, and <a class="el" href="../../#l01454">transform_center()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01465">build_octree()</a>, and <a class="el" href="../../#l01454">transform_center()</a>.</p>
<div id="dynsection-20" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-20-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-20-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-20-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a9db146374c8ace3e761fde2bd71e8aea_cgraph.svg" width="142" height="76"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-21" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-21-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-21-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-21-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a9db146374c8ace3e761fde2bd71e8aea_icgraph.svg" width="498" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6bbdd2308edf307ac8e47f65d3ae1740" name="a6bbdd2308edf307ac8e47f65d3ae1740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbdd2308edf307ac8e47f65d3ae1740">&#9670;&#160;</a></span>transform_to_octree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d00/group___geometry___module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> Slic3r::FillAdaptive::transform_to_octree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  408</span>{</div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(- octree_rot[0], Vec3d::UnitX()) * <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(- octree_rot[1], Vec3d::UnitY()) * <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(- octree_rot[2], Vec3d::UnitZ());</div>
<div class="line"><span class="lineno">  410</span>}</div>
<div class="ttc" id="agroup___geometry___module_html_gaed936d6e9192d97f00a9608081fa9b64"><div class="ttname"><a href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a></div><div class="ttdeci">AngleAxis&lt; double &gt; AngleAxisd</div><div class="ttdef"><b>Definition</b> AngleAxis.h:160</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00400">octree_rot</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01465">build_octree()</a>.</p>
<div id="dynsection-22" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-22-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-22-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-22-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a6bbdd2308edf307ac8e47f65d3ae1740_icgraph.svg" width="514" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3852c9049cfd6489d75430d404c3decd" name="a3852c9049cfd6489d75430d404c3decd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3852c9049cfd6489d75430d404c3decd">&#9670;&#160;</a></span>transform_to_world()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d00/group___geometry___module.html#ga5daab8e66aa480465000308455578830">Eigen::Quaterniond</a> Slic3r::FillAdaptive::transform_to_world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  403</span>{</div>
<div class="line"><span class="lineno">  404</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(octree_rot[2], Vec3d::UnitZ()) * <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(octree_rot[1], Vec3d::UnitY()) * <a class="code hl_typedef" href="../../d5/d00/group___geometry___module.html#gaed936d6e9192d97f00a9608081fa9b64">Eigen::AngleAxisd</a>(octree_rot[0], Vec3d::UnitX());</div>
<div class="line"><span class="lineno">  405</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00400">octree_rot</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01465">build_octree()</a>, and <a class="el" href="../../#l00415">verify_traversal_order()</a>.</p>
<div id="dynsection-23" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-23-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-23-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-23-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a3852c9049cfd6489d75430d404c3decd_icgraph.svg" width="100%" height="432"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="adc8b636ad8932e70ba36382ebb886607" name="adc8b636ad8932e70ba36382ebb886607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8b636ad8932e70ba36382ebb886607">&#9670;&#160;</a></span>triangle_AABB_intersects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Slic3r::FillAdaptive::triangle_AABB_intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html">BoundingBoxBase</a>&lt; <a class="el" href="../../de/db8/namespace_slic3r.html#a885e8a33a527bbf9e6ed748d180ea4bb">Vector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   43</span>{</div>
<div class="line"><span class="lineno">   44</span>    <span class="keyword">using </span>Scalar = <span class="keyword">typename</span> <a class="code hl_typedef" href="../../da/d8d/class_eigen_1_1_plain_object_base.html#a7f978b0b6cad676c9d01c2840f8113f5">Vector::Scalar</a>;</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> tMin = a.cwiseMin(b.cwiseMin(c));</div>
<div class="line"><span class="lineno">   47</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> tMax = a.cwiseMax(b.cwiseMax(c));</div>
<div class="line"><span class="lineno">   48</span> </div>
<div class="line"><span class="lineno">   49</span>    <span class="keywordflow">if</span> (tMin.x() &gt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">max</a>.x() || tMax.x() &lt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#ac249c80f8bbfde86457794be35e12ea9">min</a>.x()</div>
<div class="line"><span class="lineno">   50</span>        || tMin.y() &gt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">max</a>.y() || tMax.y() &lt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#ac249c80f8bbfde86457794be35e12ea9">min</a>.y()</div>
<div class="line"><span class="lineno">   51</span>        || tMin.z() &gt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">max</a>.z() || tMax.z() &lt;= aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#ac249c80f8bbfde86457794be35e12ea9">min</a>.z())</div>
<div class="line"><span class="lineno">   52</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> center = (aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#ac249c80f8bbfde86457794be35e12ea9">min</a> + aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">max</a>) * 0.5f;</div>
<div class="line"><span class="lineno">   55</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> h = aabb.<a class="code hl_variable" href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">max</a> - center;</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> t[3] { b-a, c-a, c-b };</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> ac = a - center;</div>
<div class="line"><span class="lineno">   60</span> </div>
<div class="line"><span class="lineno">   61</span>    <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> n = t[0].cross(t[1]);</div>
<div class="line"><span class="lineno">   62</span>    Scalar s = n.dot(ac);</div>
<div class="line"><span class="lineno">   63</span>    Scalar r = std::abs(h.dot(n.cwiseAbs()));</div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">if</span> (abs(s) &gt;= r)</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d6/dec/class_slic3r_1_1_point.html">Vector</a> at[3] = { t[0].cwiseAbs(), t[1].cwiseAbs(), t[2].cwiseAbs() };</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>    Vector bc = b - center;</div>
<div class="line"><span class="lineno">   70</span>    Vector cc = c - center;</div>
<div class="line"><span class="lineno">   71</span> </div>
<div class="line"><span class="lineno">   72</span>    <span class="comment">// SAT test all cross-axes.</span></div>
<div class="line"><span class="lineno">   73</span>    <span class="comment">// The following is a fully unrolled loop of this code, stored here for reference:</span></div>
<div class="line"><span class="lineno">   74</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">   75</span><span class="comment">    Scalar d1, d2, a1, a2;</span></div>
<div class="line"><span class="lineno">   76</span><span class="comment">    const Vector e[3] = { DIR_VEC(1, 0, 0), DIR_VEC(0, 1, 0), DIR_VEC(0, 0, 1) };</span></div>
<div class="line"><span class="lineno">   77</span><span class="comment">    for(int i = 0; i &lt; 3; ++i)</span></div>
<div class="line"><span class="lineno">   78</span><span class="comment">        for(int j = 0; j &lt; 3; ++j)</span></div>
<div class="line"><span class="lineno">   79</span><span class="comment">        {</span></div>
<div class="line"><span class="lineno">   80</span><span class="comment">            Vector axis = Cross(e[i], t[j]);</span></div>
<div class="line"><span class="lineno">   81</span><span class="comment">            ProjectToAxis(axis, d1, d2);</span></div>
<div class="line"><span class="lineno">   82</span><span class="comment">            aabb.ProjectToAxis(axis, a1, a2);</span></div>
<div class="line"><span class="lineno">   83</span><span class="comment">            if (d2 &lt;= a1 || d1 &gt;= a2) return false;</span></div>
<div class="line"><span class="lineno">   84</span><span class="comment">        }</span></div>
<div class="line"><span class="lineno">   85</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="comment">// eX &lt;cross&gt; t[0]</span></div>
<div class="line"><span class="lineno">   88</span>    Scalar d1 = t[0].y() * ac.z() - t[0].z() * ac.y();</div>
<div class="line"><span class="lineno">   89</span>    Scalar d2 = t[0].y() * cc.z() - t[0].z() * cc.y();</div>
<div class="line"><span class="lineno">   90</span>    Scalar tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">   91</span>    r = std::abs(h.y() * at[0].z() + h.z() * at[0].y());</div>
<div class="line"><span class="lineno">   92</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">   93</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   94</span> </div>
<div class="line"><span class="lineno">   95</span>    <span class="comment">// eX &lt;cross&gt; t[1]</span></div>
<div class="line"><span class="lineno">   96</span>    d1 = t[1].y() * ac.z() - t[1].z() * ac.y();</div>
<div class="line"><span class="lineno">   97</span>    d2 = t[1].y() * bc.z() - t[1].z() * bc.y();</div>
<div class="line"><span class="lineno">   98</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">   99</span>    r = std::abs(h.y() * at[1].z() + h.z() * at[1].y());</div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  101</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  102</span> </div>
<div class="line"><span class="lineno">  103</span>    <span class="comment">// eX &lt;cross&gt; t[2]</span></div>
<div class="line"><span class="lineno">  104</span>    d1 = t[2].y() * ac.z() - t[2].z() * ac.y();</div>
<div class="line"><span class="lineno">  105</span>    d2 = t[2].y() * bc.z() - t[2].z() * bc.y();</div>
<div class="line"><span class="lineno">  106</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  107</span>    r = std::abs(h.y() * at[2].z() + h.z() * at[2].y());</div>
<div class="line"><span class="lineno">  108</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  109</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span>    <span class="comment">// eY &lt;cross&gt; t[0]</span></div>
<div class="line"><span class="lineno">  112</span>    d1 = t[0].z() * ac.x() - t[0].x() * ac.z();</div>
<div class="line"><span class="lineno">  113</span>    d2 = t[0].z() * cc.x() - t[0].x() * cc.z();</div>
<div class="line"><span class="lineno">  114</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  115</span>    r = std::abs(h.x() * at[0].z() + h.z() * at[0].x());</div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span>    <span class="comment">// eY &lt;cross&gt; t[1]</span></div>
<div class="line"><span class="lineno">  120</span>    d1 = t[1].z() * ac.x() - t[1].x() * ac.z();</div>
<div class="line"><span class="lineno">  121</span>    d2 = t[1].z() * bc.x() - t[1].x() * bc.z();</div>
<div class="line"><span class="lineno">  122</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  123</span>    r = std::abs(h.x() * at[1].z() + h.z() * at[1].x());</div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="comment">// eY &lt;cross&gt; t[2]</span></div>
<div class="line"><span class="lineno">  128</span>    d1 = t[2].z() * ac.x() - t[2].x() * ac.z();</div>
<div class="line"><span class="lineno">  129</span>    d2 = t[2].z() * bc.x() - t[2].x() * bc.z();</div>
<div class="line"><span class="lineno">  130</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  131</span>    r = std::abs(h.x() * at[2].z() + h.z() * at[2].x());</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  133</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    <span class="comment">// eZ &lt;cross&gt; t[0]</span></div>
<div class="line"><span class="lineno">  136</span>    d1 = t[0].x() * ac.y() - t[0].y() * ac.x();</div>
<div class="line"><span class="lineno">  137</span>    d2 = t[0].x() * cc.y() - t[0].y() * cc.x();</div>
<div class="line"><span class="lineno">  138</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  139</span>    r = std::abs(h.y() * at[0].x() + h.x() * at[0].y());</div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <span class="comment">// eZ &lt;cross&gt; t[1]</span></div>
<div class="line"><span class="lineno">  144</span>    d1 = t[1].x() * ac.y() - t[1].y() * ac.x();</div>
<div class="line"><span class="lineno">  145</span>    d2 = t[1].x() * bc.y() - t[1].y() * bc.x();</div>
<div class="line"><span class="lineno">  146</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  147</span>    r = std::abs(h.y() * at[1].x() + h.x() * at[1].y());</div>
<div class="line"><span class="lineno">  148</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  149</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  150</span> </div>
<div class="line"><span class="lineno">  151</span>    <span class="comment">// eZ &lt;cross&gt; t[2]</span></div>
<div class="line"><span class="lineno">  152</span>    d1 = t[2].x() * ac.y() - t[2].y() * ac.x();</div>
<div class="line"><span class="lineno">  153</span>    d2 = t[2].x() * bc.y() - t[2].y() * bc.x();</div>
<div class="line"><span class="lineno">  154</span>    tc = (d1 + d2) * 0.5f;</div>
<div class="line"><span class="lineno">  155</span>    r = std::abs(h.y() * at[2].x() + h.x() * at[2].y());</div>
<div class="line"><span class="lineno">  156</span>    <span class="keywordflow">if</span> (r + std::abs(tc - d1) &lt; std::abs(tc))</div>
<div class="line"><span class="lineno">  157</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  158</span> </div>
<div class="line"><span class="lineno">  159</span>    <span class="comment">// No separating axis exists, the AABB and triangle intersect.</span></div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  161</span>}</div>
<div class="ttc" id="aclass_eigen_1_1_plain_object_base_html_a7f978b0b6cad676c9d01c2840f8113f5"><div class="ttname"><a href="../../da/d8d/class_eigen_1_1_plain_object_base.html#a7f978b0b6cad676c9d01c2840f8113f5">Eigen::PlainObjectBase::Scalar</a></div><div class="ttdeci">internal::traits&lt; Derived &gt;::Scalar Scalar</div><div class="ttdef"><b>Definition</b> PlainObjectBase.h:106</div></div>
<div class="ttc" id="aclass_slic3r_1_1_bounding_box_base_html_a1382e0a608cd3261f2506f7b48d60857"><div class="ttname"><a href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#a1382e0a608cd3261f2506f7b48d60857">Slic3r::BoundingBoxBase::max</a></div><div class="ttdeci">PointType max</div><div class="ttdef"><b>Definition</b> BoundingBox.hpp:17</div></div>
<div class="ttc" id="aclass_slic3r_1_1_bounding_box_base_html_ac249c80f8bbfde86457794be35e12ea9"><div class="ttname"><a href="../../dc/d28/class_slic3r_1_1_bounding_box_base.html#ac249c80f8bbfde86457794be35e12ea9">Slic3r::BoundingBoxBase::min</a></div><div class="ttdeci">PointType min</div><div class="ttdef"><b>Definition</b> BoundingBox.hpp:16</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00017">Slic3r::BoundingBoxBase&lt; PointType, APointsType &gt;::max</a>, and <a class="el" href="../../#l00016">Slic3r::BoundingBoxBase&lt; PointType, APointsType &gt;::min</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01515">Slic3r::FillAdaptive::Octree::insert_triangle()</a>.</p>
<div id="dynsection-24" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-24-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-24-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-24-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_adc8b636ad8932e70ba36382ebb886607_icgraph.svg" width="100%" height="362"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a62b6c3850ee31bb8711301708ef104a9" name="a62b6c3850ee31bb8711301708ef104a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b6c3850ee31bb8711301708ef104a9">&#9670;&#160;</a></span>validate_intersection_t_joint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Slic3r::FillAdaptive::validate_intersection_t_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &amp;&#160;</td>
          <td class="paramname"><em>intersection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  781</span>{</div>
<div class="line"><span class="lineno">  782</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a>  v = (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;b - <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  783</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec2d</a>  va = (<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.intersect_point - <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>.closest_line-&gt;a).cast&lt;double&gt;();</div>
<div class="line"><span class="lineno">  784</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a> = v.squaredNorm();  <span class="comment">// avoid a sqrt</span></div>
<div class="line"><span class="lineno">  785</span>    assert(l2 &gt; 0.);</div>
<div class="line"><span class="lineno">  786</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> t = va.dot(v);</div>
<div class="line"><span class="lineno">  787</span>    assert(t &gt; <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a> &amp;&amp; t &lt; l2 - <a class="code hl_define" href="../../dd/d47/libslic3r_8h.html#a57f3510310e75de35abd65c9650b49f7">SCALED_EPSILON</a>);</div>
<div class="line"><span class="lineno">  788</span>    <span class="keyword">const</span> <span class="keywordtype">double</span> d = ((t / <a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a1e045f56a994b8cd4a5b203626cd8272">l2</a>) * v - va).norm();</div>
<div class="line"><span class="lineno">  789</span>    assert(d &lt; 1000.);</div>
<div class="line"><span class="lineno">  790</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  791</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00686">Slic3r::intersection()</a>, <a class="el" href="../../#l00166">Slic3r::l2()</a>, and <a class="el" href="../../#l00071">SCALED_EPSILON</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>, and <a class="el" href="../../#l00792">validate_intersections()</a>.</p>
<div id="dynsection-25" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-25-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-25-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-25-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a62b6c3850ee31bb8711301708ef104a9_cgraph.svg" width="100%" height="364"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-26" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-26-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-26-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-26-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a62b6c3850ee31bb8711301708ef104a9_icgraph.svg" width="600" height="87"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3e8df2806894ebc7012c77ec366d8525" name="a3e8df2806894ebc7012c77ec366d8525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8df2806894ebc7012c77ec366d8525">&#9670;&#160;</a></span>validate_intersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Slic3r::FillAdaptive::validate_intersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; <a class="el" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersections</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  793</span>{</div>
<div class="line"><span class="lineno">  794</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_struct" href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Intersection</a>&amp; intersection : intersections)</div>
<div class="line"><span class="lineno">  795</span>        assert(<a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a62b6c3850ee31bb8711301708ef104a9">validate_intersection_t_joint</a>(<a class="code hl_function" href="../../de/db8/namespace_slic3r.html#a57c612ab2aa7dd29f1e7ece220e3af82">intersection</a>));</div>
<div class="line"><span class="lineno">  796</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  797</span>}</div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_intersection_html"><div class="ttname"><a href="../../dc/da2/struct_slic3r_1_1_fill_adaptive_1_1_intersection.html">Slic3r::FillAdaptive::Intersection</a></div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:562</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00686">Slic3r::intersection()</a>, and <a class="el" href="../../#l00780">validate_intersection_t_joint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00800">connect_lines_using_hooks()</a>.</p>
<div id="dynsection-27" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-27-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-27-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-27-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a3e8df2806894ebc7012c77ec366d8525_cgraph.svg" width="100%" height="382"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-28" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-28-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-28-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-28-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a3e8df2806894ebc7012c77ec366d8525_icgraph.svg" width="404" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a14a6caaeff32208a7480ba764336689f" name="a14a6caaeff32208a7480ba764336689f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a6caaeff32208a7480ba764336689f">&#9670;&#160;</a></span>verify_traversal_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slic3r::FillAdaptive::verify_traversal_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html">FillContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../d5/d34/struct_slic3r_1_1_fill_adaptive_1_1_cube.html">Cube</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> &amp;&#160;</td>
          <td class="paramname"><em>line_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="../../de/db8/namespace_slic3r.html#a40e8e384542f32f8150cabd3db031651">Vec2d</a> &amp;&#160;</td>
          <td class="paramname"><em>line_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  421</span>{</div>
<div class="line"><span class="lineno">  422</span>    std::array&lt;Vec3d, 8&gt; c;</div>
<div class="line"><span class="lineno">  423</span>    <a class="code hl_class" href="../../d5/d00/group___geometry___module.html#d3/d2e/class_eigen_1_1_quaternion">Eigen::Quaterniond</a> to_world = <a class="code hl_function" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3852c9049cfd6489d75430d404c3decd">transform_to_world</a>();</div>
<div class="line"><span class="lineno">  424</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; ++i) {</div>
<div class="line"><span class="lineno">  425</span>        <span class="keywordtype">int</span> j = context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#ad8da521ffec03f5fc0ae5edb67c1514e">traversal_order</a>[i];</div>
<div class="line"><span class="lineno">  426</span>        <a class="code hl_class" href="../../d2/d2d/class_eigen_1_1_matrix.html">Vec3d</a> cntr = to_world * (<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;center_octree + (<a class="code hl_variable" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a98f3219a051c667f9d93ce9627882a47">child_centers</a>[j] * (context.<a class="code hl_variable" href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#a23c0f89314309dd83752f68bc4e15f5f">cubes_properties</a>[depth].edge_length / 4.)));</div>
<div class="line"><span class="lineno">  427</span>        assert(!<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;children[j] || <a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#ad816d4a0c05f21e660e91e9febb1b900">cube</a>-&gt;children[j]-&gt;center.isApprox(cntr));</div>
<div class="line"><span class="lineno">  428</span>        c[i] = cntr;</div>
<div class="line"><span class="lineno">  429</span>    }</div>
<div class="line"><span class="lineno">  430</span>    std::array&lt;Vec3d, 10&gt; dirs = {</div>
<div class="line"><span class="lineno">  431</span>        c[1] - c[0], c[2] - c[0], c[3] - c[1], c[3] - c[2], c[3] - c[0],</div>
<div class="line"><span class="lineno">  432</span>        c[5] - c[4], c[6] - c[4], c[7] - c[5], c[7] - c[6], c[7] - c[4]</div>
<div class="line"><span class="lineno">  433</span>    };</div>
<div class="line"><span class="lineno">  434</span>    assert(std::abs(dirs[4].z()) &lt; 0.005);</div>
<div class="line"><span class="lineno">  435</span>    assert(std::abs(dirs[9].z()) &lt; 0.005);</div>
<div class="line"><span class="lineno">  436</span>    assert(dirs[0].isApprox(dirs[3]));</div>
<div class="line"><span class="lineno">  437</span>    assert(dirs[1].isApprox(dirs[2]));</div>
<div class="line"><span class="lineno">  438</span>    assert(dirs[5].isApprox(dirs[8]));</div>
<div class="line"><span class="lineno">  439</span>    assert(dirs[6].isApprox(dirs[7]));</div>
<div class="line"><span class="lineno">  440</span>    Vec3d line_dir = Vec3d(line_to.x() - line_from.x(), line_to.y() - line_from.y(), 0.).normalized();</div>
<div class="line"><span class="lineno">  441</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; dir : dirs) {</div>
<div class="line"><span class="lineno">  442</span>        <span class="keywordtype">double</span> d = dir.normalized().dot(line_dir);</div>
<div class="line"><span class="lineno">  443</span>        assert(d &gt; 0.7);</div>
<div class="line"><span class="lineno">  444</span>    }</div>
<div class="line"><span class="lineno">  445</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  446</span>}</div>
<div class="ttc" id="agroup___geometry___module_html_d3/d2e/class_eigen_1_1_quaternion"><div class="ttname"><a href="../../d5/d00/group___geometry___module.html#d3/d2e/class_eigen_1_1_quaternion">Eigen::Quaternion</a></div><div class="ttdoc">The quaternion class used to represent 3D orientations and rotations.</div><div class="ttdef"><b>Definition</b> Quaternion.h:233</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a3852c9049cfd6489d75430d404c3decd"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a3852c9049cfd6489d75430d404c3decd">Slic3r::FillAdaptive::transform_to_world</a></div><div class="ttdeci">Eigen::Quaterniond transform_to_world()</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:402</div></div>
<div class="ttc" id="anamespace_slic3r_1_1_fill_adaptive_html_a98f3219a051c667f9d93ce9627882a47"><div class="ttname"><a href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html#a98f3219a051c667f9d93ce9627882a47">Slic3r::FillAdaptive::child_centers</a></div><div class="ttdeci">static const std::array&lt; Vec3d, 8 &gt; child_centers</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:225</div></div>
<div class="ttc" id="astruct_slic3r_1_1_fill_adaptive_1_1_fill_context_html_ad8da521ffec03f5fc0ae5edb67c1514e"><div class="ttname"><a href="../../d1/d23/struct_slic3r_1_1_fill_adaptive_1_1_fill_context.html#ad8da521ffec03f5fc0ae5edb67c1514e">Slic3r::FillAdaptive::FillContext::traversal_order</a></div><div class="ttdeci">const std::array&lt; int, 8 &gt; traversal_order</div><div class="ttdef"><b>Definition</b> FillAdaptive.cpp:388</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00225">child_centers</a>, <a class="el" href="../../#l00360">cube()</a>, <a class="el" href="../../#l00384">Slic3r::FillAdaptive::FillContext::cubes_properties</a>, <a class="el" href="../../#l00402">transform_to_world()</a>, and <a class="el" href="../../#l00388">Slic3r::FillAdaptive::FillContext::traversal_order</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00449">generate_infill_lines_recursive()</a>.</p>
<div id="dynsection-29" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-29-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-29-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-29-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a14a6caaeff32208a7480ba764336689f_cgraph.svg" width="354" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-30" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-30-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-30-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-30-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d6/d08/namespace_slic3r_1_1_fill_adaptive_a14a6caaeff32208a7480ba764336689f_icgraph.svg" width="540" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a98f3219a051c667f9d93ce9627882a47" name="a98f3219a051c667f9d93ce9627882a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f3219a051c667f9d93ce9627882a47">&#9670;&#160;</a></span>child_centers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d53/getopt_8c.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::array&lt;<a class="el" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>, 8&gt; Slic3r::FillAdaptive::child_centers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>(-1, -1, -1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>( 1, -1, -1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>(-1,  1, -1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>( 1,  1, -1),</div>
<div class="line">    <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>(-1, -1,  1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>( 1, -1,  1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>(-1,  1,  1), <a class="code hl_typedef" href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Vec3d</a>( 1,  1,  1)</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_slic3r_html_a6b8e15a6e63fb72a48bc5e49b8a6f6b1"><div class="ttname"><a href="../../de/db8/namespace_slic3r.html#a6b8e15a6e63fb72a48bc5e49b8a6f6b1">Slic3r::Vec3d</a></div><div class="ttdeci">Eigen::Matrix&lt; double, 3, 1, Eigen::DontAlign &gt; Vec3d</div><div class="ttdef"><b>Definition</b> Point.hpp:52</div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01515">Slic3r::FillAdaptive::Octree::insert_triangle()</a>, and <a class="el" href="../../#l00415">verify_traversal_order()</a>.</p>

</div>
</div>
<a id="afc7a3f285c9e9cb0dcb4b21d45f70cf8" name="afc7a3f285c9e9cb0dcb4b21d45f70cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7a3f285c9e9cb0dcb4b21d45f70cf8">&#9670;&#160;</a></span>child_traversal_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;std::array&lt;int, 8&gt;, 3&gt; Slic3r::FillAdaptive::child_traversal_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    std::array&lt;int, 8&gt;{ 2, 3, 0, 1, 6, 7, 4, 5 },</div>
<div class="line">    std::array&lt;int, 8&gt;{ 4, 0, 6, 2, 5, 1, 7, 3 },</div>
<div class="line">    std::array&lt;int, 8&gt;{ 1, 5, 0, 4, 3, 7, 2, 6 },</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa491a87bb43c2acacebd4bd7a77cff67" name="aa491a87bb43c2acacebd4bd7a77cff67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa491a87bb43c2acacebd4bd7a77cff67">&#9670;&#160;</a></span>octree_rot</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double Slic3r::FillAdaptive::octree_rot[3] = { 5.0 * <a class="el" href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 4.0, <a class="el" href="../../d3/dfb/namespace_slic3r_1_1_geometry.html#a345f6f1e6238a364b20bdabac88a8314">Geometry::deg2rad</a>(215.264), <a class="el" href="../../de/ddd/_extrusion_simulator_8cpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / 6.0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../#l00407">transform_to_octree()</a>, and <a class="el" href="../../#l00402">transform_to_world()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/db8/namespace_slic3r.html">Slic3r</a></li><li class="navelem"><a class="el" href="../../d6/d08/namespace_slic3r_1_1_fill_adaptive.html">FillAdaptive</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
